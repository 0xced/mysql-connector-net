// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Mysqlx.Expr {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal static partial class MysqlxExpr {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_Expr__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Expr, global::Mysqlx.Expr.Expr.Builder> internal__static_Mysqlx_Expr_Expr__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_Identifier__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Identifier, global::Mysqlx.Expr.Identifier.Builder> internal__static_Mysqlx_Expr_Identifier__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_DocumentPathItem__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.DocumentPathItem, global::Mysqlx.Expr.DocumentPathItem.Builder> internal__static_Mysqlx_Expr_DocumentPathItem__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_ColumnIdentifier__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.ColumnIdentifier, global::Mysqlx.Expr.ColumnIdentifier.Builder> internal__static_Mysqlx_Expr_ColumnIdentifier__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_FunctionCall__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.FunctionCall, global::Mysqlx.Expr.FunctionCall.Builder> internal__static_Mysqlx_Expr_FunctionCall__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_Operator__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Operator, global::Mysqlx.Expr.Operator.Builder> internal__static_Mysqlx_Expr_Operator__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static MysqlxExpr() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "ChFteXNxbHhfZXhwci5wcm90bxILTXlzcWx4LkV4cHIaFm15c3FseF9kYXRh" + 
          "dHlwZXMucHJvdG8i0QIKBEV4cHISJAoEdHlwZRgBIAIoDjIWLk15c3FseC5F" + 
          "eHByLkV4cHIuVHlwZRIxCgppZGVudGlmaWVyGAIgASgLMh0uTXlzcWx4LkV4" + 
          "cHIuQ29sdW1uSWRlbnRpZmllchIQCgh2YXJpYWJsZRgDIAEoCRInCghjb25z" + 
          "dGFudBgEIAEoCzIVLk15c3FseC5EYXRhdHlwZXMuQW55EjAKDWZ1bmN0aW9u" + 
          "X2NhbGwYBSABKAsyGS5NeXNxbHguRXhwci5GdW5jdGlvbkNhbGwSJwoIb3Bl" + 
          "cmF0b3IYBiABKAsyFS5NeXNxbHguRXhwci5PcGVyYXRvciJaCgRUeXBlEgkK" + 
          "BUlERU5UEAESCwoHTElURVJBTBACEgwKCFZBUklBQkxFEAMSDQoJRlVOQ19D" + 
          "QUxMEAQSDAoIT1BFUkFUT1IQBRIPCgtQTEFDRUhPTERFUhAGIi8KCklkZW50" + 
          "aWZpZXISDAoEbmFtZRgBIAIoCRITCgtzY2hlbWFfbmFtZRgCIAEoCSLLAQoQ" + 
          "RG9jdW1lbnRQYXRoSXRlbRIwCgR0eXBlGAEgAigOMiIuTXlzcWx4LkV4cHIu" + 
          "RG9jdW1lbnRQYXRoSXRlbS5UeXBlEg0KBXZhbHVlGAIgASgJEg0KBWluZGV4" + 
          "GAMgASgNImcKBFR5cGUSCgoGTUVNQkVSEAESEwoPTUVNQkVSX0FTVEVSSVNL" + 
          "EAISDwoLQVJSQVlfSU5ERVgQAxIYChRBUlJBWV9JTkRFWF9BU1RFUklTSxAE" + 
          "EhMKD0RPVUJMRV9BU1RFUklTSxAFIn8KEENvbHVtbklkZW50aWZpZXISNAoN" + 
          "ZG9jdW1lbnRfcGF0aBgBIAMoCzIdLk15c3FseC5FeHByLkRvY3VtZW50UGF0" + 
          "aEl0ZW0SDAoEbmFtZRgCIAEoCRISCgp0YWJsZV9uYW1lGAMgASgJEhMKC3Nj" + 
          "aGVtYV9uYW1lGAQgASgJIlcKDEZ1bmN0aW9uQ2FsbBIlCgRuYW1lGAEgAigL" + 
          "MhcuTXlzcWx4LkV4cHIuSWRlbnRpZmllchIgCgVwYXJhbRgCIAMoCzIRLk15" + 
          "c3FseC5FeHByLkV4cHIiOgoIT3BlcmF0b3ISDAoEbmFtZRgBIAIoCRIgCgVw" + 
          "YXJhbRgCIAMoCzIRLk15c3FseC5FeHByLkV4cHJCHgocY29tLm15c3FsLmNq" + 
          "Lm15c3FseC5wcm90b2J1Zg==");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Mysqlx_Expr_Expr__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Mysqlx_Expr_Expr__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Expr, global::Mysqlx.Expr.Expr.Builder>(internal__static_Mysqlx_Expr_Expr__Descriptor,
                new string[] { "Type", "Identifier", "Variable", "Constant", "FunctionCall", "Operator", });
        internal__static_Mysqlx_Expr_Identifier__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Mysqlx_Expr_Identifier__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Identifier, global::Mysqlx.Expr.Identifier.Builder>(internal__static_Mysqlx_Expr_Identifier__Descriptor,
                new string[] { "Name", "SchemaName", });
        internal__static_Mysqlx_Expr_DocumentPathItem__Descriptor = Descriptor.MessageTypes[2];
        internal__static_Mysqlx_Expr_DocumentPathItem__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.DocumentPathItem, global::Mysqlx.Expr.DocumentPathItem.Builder>(internal__static_Mysqlx_Expr_DocumentPathItem__Descriptor,
                new string[] { "Type", "Value", "Index", });
        internal__static_Mysqlx_Expr_ColumnIdentifier__Descriptor = Descriptor.MessageTypes[3];
        internal__static_Mysqlx_Expr_ColumnIdentifier__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.ColumnIdentifier, global::Mysqlx.Expr.ColumnIdentifier.Builder>(internal__static_Mysqlx_Expr_ColumnIdentifier__Descriptor,
                new string[] { "DocumentPath", "Name", "TableName", "SchemaName", });
        internal__static_Mysqlx_Expr_FunctionCall__Descriptor = Descriptor.MessageTypes[4];
        internal__static_Mysqlx_Expr_FunctionCall__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.FunctionCall, global::Mysqlx.Expr.FunctionCall.Builder>(internal__static_Mysqlx_Expr_FunctionCall__Descriptor,
                new string[] { "Name", "Param", });
        internal__static_Mysqlx_Expr_Operator__Descriptor = Descriptor.MessageTypes[5];
        internal__static_Mysqlx_Expr_Operator__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Operator, global::Mysqlx.Expr.Operator.Builder>(internal__static_Mysqlx_Expr_Operator__Descriptor,
                new string[] { "Name", "Param", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          global::Mysqlx.Datatypes.MysqlxDatatypes.Descriptor, 
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Expr : pb::GeneratedMessage<Expr, Expr.Builder> {
    private Expr() { }
    private static readonly Expr defaultInstance = new Expr().MakeReadOnly();
    private static readonly string[] _exprFieldNames = new string[] { "constant", "function_call", "identifier", "operator", "type", "variable" };
    private static readonly uint[] _exprFieldTags = new uint[] { 34, 42, 18, 50, 8, 26 };
    public static Expr DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Expr DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Expr ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Expr__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Expr, Expr.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Expr__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      internal enum Type {
        IDENT = 1,
        LITERAL = 2,
        VARIABLE = 3,
        FUNC_CALL = 4,
        OPERATOR = 5,
        PLACEHOLDER = 6,
      }
      
    }
    #endregion
    
    public const int TypeFieldNumber = 1;
    private bool hasType;
    private global::Mysqlx.Expr.Expr.Types.Type type_ = global::Mysqlx.Expr.Expr.Types.Type.IDENT;
    public bool HasType {
      get { return hasType; }
    }
    public global::Mysqlx.Expr.Expr.Types.Type Type {
      get { return type_; }
    }
    
    public const int IdentifierFieldNumber = 2;
    private bool hasIdentifier;
    private global::Mysqlx.Expr.ColumnIdentifier identifier_;
    public bool HasIdentifier {
      get { return hasIdentifier; }
    }
    public global::Mysqlx.Expr.ColumnIdentifier Identifier {
      get { return identifier_ ?? global::Mysqlx.Expr.ColumnIdentifier.DefaultInstance; }
    }
    
    public const int VariableFieldNumber = 3;
    private bool hasVariable;
    private string variable_ = "";
    public bool HasVariable {
      get { return hasVariable; }
    }
    public string Variable {
      get { return variable_; }
    }
    
    public const int ConstantFieldNumber = 4;
    private bool hasConstant;
    private global::Mysqlx.Datatypes.Any constant_;
    public bool HasConstant {
      get { return hasConstant; }
    }
    public global::Mysqlx.Datatypes.Any Constant {
      get { return constant_ ?? global::Mysqlx.Datatypes.Any.DefaultInstance; }
    }
    
    public const int FunctionCallFieldNumber = 5;
    private bool hasFunctionCall;
    private global::Mysqlx.Expr.FunctionCall functionCall_;
    public bool HasFunctionCall {
      get { return hasFunctionCall; }
    }
    public global::Mysqlx.Expr.FunctionCall FunctionCall {
      get { return functionCall_ ?? global::Mysqlx.Expr.FunctionCall.DefaultInstance; }
    }
    
    public const int OperatorFieldNumber = 6;
    private bool hasOperator;
    private global::Mysqlx.Expr.Operator operator_;
    public bool HasOperator {
      get { return hasOperator; }
    }
    public global::Mysqlx.Expr.Operator Operator {
      get { return operator_ ?? global::Mysqlx.Expr.Operator.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasType) return false;
        if (HasIdentifier) {
          if (!Identifier.IsInitialized) return false;
        }
        if (HasConstant) {
          if (!Constant.IsInitialized) return false;
        }
        if (HasFunctionCall) {
          if (!FunctionCall.IsInitialized) return false;
        }
        if (HasOperator) {
          if (!Operator.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _exprFieldNames;
      if (hasType) {
        output.WriteEnum(1, field_names[4], (int) Type, Type);
      }
      if (hasIdentifier) {
        output.WriteMessage(2, field_names[2], Identifier);
      }
      if (hasVariable) {
        output.WriteString(3, field_names[5], Variable);
      }
      if (hasConstant) {
        output.WriteMessage(4, field_names[0], Constant);
      }
      if (hasFunctionCall) {
        output.WriteMessage(5, field_names[1], FunctionCall);
      }
      if (hasOperator) {
        output.WriteMessage(6, field_names[3], Operator);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasType) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Type);
        }
        if (hasIdentifier) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Identifier);
        }
        if (hasVariable) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Variable);
        }
        if (hasConstant) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, Constant);
        }
        if (hasFunctionCall) {
          size += pb::CodedOutputStream.ComputeMessageSize(5, FunctionCall);
        }
        if (hasOperator) {
          size += pb::CodedOutputStream.ComputeMessageSize(6, Operator);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Expr ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Expr ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Expr ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Expr ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Expr ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Expr ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Expr ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Expr ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Expr ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Expr ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Expr MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Expr prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Expr, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Expr cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Expr result;
      
      private Expr PrepareBuilder() {
        if (resultIsReadOnly) {
          Expr original = result;
          result = new Expr();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Expr MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.Expr.Descriptor; }
      }
      
      public override Expr DefaultInstanceForType {
        get { return global::Mysqlx.Expr.Expr.DefaultInstance; }
      }
      
      public override Expr BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Expr) {
          return MergeFrom((Expr) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Expr other) {
        if (other == global::Mysqlx.Expr.Expr.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasIdentifier) {
          MergeIdentifier(other.Identifier);
        }
        if (other.HasVariable) {
          Variable = other.Variable;
        }
        if (other.HasConstant) {
          MergeConstant(other.Constant);
        }
        if (other.HasFunctionCall) {
          MergeFunctionCall(other.FunctionCall);
        }
        if (other.HasOperator) {
          MergeOperator(other.Operator);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_exprFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _exprFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.type_, out unknown)) {
                result.hasType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              global::Mysqlx.Expr.ColumnIdentifier.Builder subBuilder = global::Mysqlx.Expr.ColumnIdentifier.CreateBuilder();
              if (result.hasIdentifier) {
                subBuilder.MergeFrom(Identifier);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Identifier = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              result.hasVariable = input.ReadString(ref result.variable_);
              break;
            }
            case 34: {
              global::Mysqlx.Datatypes.Any.Builder subBuilder = global::Mysqlx.Datatypes.Any.CreateBuilder();
              if (result.hasConstant) {
                subBuilder.MergeFrom(Constant);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Constant = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              global::Mysqlx.Expr.FunctionCall.Builder subBuilder = global::Mysqlx.Expr.FunctionCall.CreateBuilder();
              if (result.hasFunctionCall) {
                subBuilder.MergeFrom(FunctionCall);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              FunctionCall = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              global::Mysqlx.Expr.Operator.Builder subBuilder = global::Mysqlx.Expr.Operator.CreateBuilder();
              if (result.hasOperator) {
                subBuilder.MergeFrom(Operator);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Operator = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasType {
       get { return result.hasType; }
      }
      public global::Mysqlx.Expr.Expr.Types.Type Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(global::Mysqlx.Expr.Expr.Types.Type value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = global::Mysqlx.Expr.Expr.Types.Type.IDENT;
        return this;
      }
      
      public bool HasIdentifier {
       get { return result.hasIdentifier; }
      }
      public global::Mysqlx.Expr.ColumnIdentifier Identifier {
        get { return result.Identifier; }
        set { SetIdentifier(value); }
      }
      public Builder SetIdentifier(global::Mysqlx.Expr.ColumnIdentifier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasIdentifier = true;
        result.identifier_ = value;
        return this;
      }
      public Builder SetIdentifier(global::Mysqlx.Expr.ColumnIdentifier.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasIdentifier = true;
        result.identifier_ = builderForValue.Build();
        return this;
      }
      public Builder MergeIdentifier(global::Mysqlx.Expr.ColumnIdentifier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasIdentifier &&
            result.identifier_ != global::Mysqlx.Expr.ColumnIdentifier.DefaultInstance) {
            result.identifier_ = global::Mysqlx.Expr.ColumnIdentifier.CreateBuilder(result.identifier_).MergeFrom(value).BuildPartial();
        } else {
          result.identifier_ = value;
        }
        result.hasIdentifier = true;
        return this;
      }
      public Builder ClearIdentifier() {
        PrepareBuilder();
        result.hasIdentifier = false;
        result.identifier_ = null;
        return this;
      }
      
      public bool HasVariable {
        get { return result.hasVariable; }
      }
      public string Variable {
        get { return result.Variable; }
        set { SetVariable(value); }
      }
      public Builder SetVariable(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasVariable = true;
        result.variable_ = value;
        return this;
      }
      public Builder ClearVariable() {
        PrepareBuilder();
        result.hasVariable = false;
        result.variable_ = "";
        return this;
      }
      
      public bool HasConstant {
       get { return result.hasConstant; }
      }
      public global::Mysqlx.Datatypes.Any Constant {
        get { return result.Constant; }
        set { SetConstant(value); }
      }
      public Builder SetConstant(global::Mysqlx.Datatypes.Any value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasConstant = true;
        result.constant_ = value;
        return this;
      }
      public Builder SetConstant(global::Mysqlx.Datatypes.Any.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasConstant = true;
        result.constant_ = builderForValue.Build();
        return this;
      }
      public Builder MergeConstant(global::Mysqlx.Datatypes.Any value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasConstant &&
            result.constant_ != global::Mysqlx.Datatypes.Any.DefaultInstance) {
            result.constant_ = global::Mysqlx.Datatypes.Any.CreateBuilder(result.constant_).MergeFrom(value).BuildPartial();
        } else {
          result.constant_ = value;
        }
        result.hasConstant = true;
        return this;
      }
      public Builder ClearConstant() {
        PrepareBuilder();
        result.hasConstant = false;
        result.constant_ = null;
        return this;
      }
      
      public bool HasFunctionCall {
       get { return result.hasFunctionCall; }
      }
      public global::Mysqlx.Expr.FunctionCall FunctionCall {
        get { return result.FunctionCall; }
        set { SetFunctionCall(value); }
      }
      public Builder SetFunctionCall(global::Mysqlx.Expr.FunctionCall value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFunctionCall = true;
        result.functionCall_ = value;
        return this;
      }
      public Builder SetFunctionCall(global::Mysqlx.Expr.FunctionCall.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasFunctionCall = true;
        result.functionCall_ = builderForValue.Build();
        return this;
      }
      public Builder MergeFunctionCall(global::Mysqlx.Expr.FunctionCall value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasFunctionCall &&
            result.functionCall_ != global::Mysqlx.Expr.FunctionCall.DefaultInstance) {
            result.functionCall_ = global::Mysqlx.Expr.FunctionCall.CreateBuilder(result.functionCall_).MergeFrom(value).BuildPartial();
        } else {
          result.functionCall_ = value;
        }
        result.hasFunctionCall = true;
        return this;
      }
      public Builder ClearFunctionCall() {
        PrepareBuilder();
        result.hasFunctionCall = false;
        result.functionCall_ = null;
        return this;
      }
      
      public bool HasOperator {
       get { return result.hasOperator; }
      }
      public global::Mysqlx.Expr.Operator Operator {
        get { return result.Operator; }
        set { SetOperator(value); }
      }
      public Builder SetOperator(global::Mysqlx.Expr.Operator value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOperator = true;
        result.operator_ = value;
        return this;
      }
      public Builder SetOperator(global::Mysqlx.Expr.Operator.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasOperator = true;
        result.operator_ = builderForValue.Build();
        return this;
      }
      public Builder MergeOperator(global::Mysqlx.Expr.Operator value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasOperator &&
            result.operator_ != global::Mysqlx.Expr.Operator.DefaultInstance) {
            result.operator_ = global::Mysqlx.Expr.Operator.CreateBuilder(result.operator_).MergeFrom(value).BuildPartial();
        } else {
          result.operator_ = value;
        }
        result.hasOperator = true;
        return this;
      }
      public Builder ClearOperator() {
        PrepareBuilder();
        result.hasOperator = false;
        result.operator_ = null;
        return this;
      }
    }
    static Expr() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Identifier : pb::GeneratedMessage<Identifier, Identifier.Builder> {
    private Identifier() { }
    private static readonly Identifier defaultInstance = new Identifier().MakeReadOnly();
    private static readonly string[] _identifierFieldNames = new string[] { "name", "schema_name" };
    private static readonly uint[] _identifierFieldTags = new uint[] { 10, 18 };
    public static Identifier DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Identifier DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Identifier ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Identifier__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Identifier, Identifier.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Identifier__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int SchemaNameFieldNumber = 2;
    private bool hasSchemaName;
    private string schemaName_ = "";
    public bool HasSchemaName {
      get { return hasSchemaName; }
    }
    public string SchemaName {
      get { return schemaName_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _identifierFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[0], Name);
      }
      if (hasSchemaName) {
        output.WriteString(2, field_names[1], SchemaName);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasSchemaName) {
          size += pb::CodedOutputStream.ComputeStringSize(2, SchemaName);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Identifier ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Identifier ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Identifier ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Identifier ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Identifier ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Identifier ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Identifier ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Identifier ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Identifier ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Identifier ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Identifier MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Identifier prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Identifier, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Identifier cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Identifier result;
      
      private Identifier PrepareBuilder() {
        if (resultIsReadOnly) {
          Identifier original = result;
          result = new Identifier();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Identifier MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.Identifier.Descriptor; }
      }
      
      public override Identifier DefaultInstanceForType {
        get { return global::Mysqlx.Expr.Identifier.DefaultInstance; }
      }
      
      public override Identifier BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Identifier) {
          return MergeFrom((Identifier) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Identifier other) {
        if (other == global::Mysqlx.Expr.Identifier.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasSchemaName) {
          SchemaName = other.SchemaName;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_identifierFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _identifierFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              result.hasSchemaName = input.ReadString(ref result.schemaName_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasSchemaName {
        get { return result.hasSchemaName; }
      }
      public string SchemaName {
        get { return result.SchemaName; }
        set { SetSchemaName(value); }
      }
      public Builder SetSchemaName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSchemaName = true;
        result.schemaName_ = value;
        return this;
      }
      public Builder ClearSchemaName() {
        PrepareBuilder();
        result.hasSchemaName = false;
        result.schemaName_ = "";
        return this;
      }
    }
    static Identifier() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class DocumentPathItem : pb::GeneratedMessage<DocumentPathItem, DocumentPathItem.Builder> {
    private DocumentPathItem() { }
    private static readonly DocumentPathItem defaultInstance = new DocumentPathItem().MakeReadOnly();
    private static readonly string[] _documentPathItemFieldNames = new string[] { "index", "type", "value" };
    private static readonly uint[] _documentPathItemFieldTags = new uint[] { 24, 8, 18 };
    public static DocumentPathItem DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override DocumentPathItem DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override DocumentPathItem ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_DocumentPathItem__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<DocumentPathItem, DocumentPathItem.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_DocumentPathItem__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      internal enum Type {
        MEMBER = 1,
        MEMBER_ASTERISK = 2,
        ARRAY_INDEX = 3,
        ARRAY_INDEX_ASTERISK = 4,
        DOUBLE_ASTERISK = 5,
      }
      
    }
    #endregion
    
    public const int TypeFieldNumber = 1;
    private bool hasType;
    private global::Mysqlx.Expr.DocumentPathItem.Types.Type type_ = global::Mysqlx.Expr.DocumentPathItem.Types.Type.MEMBER;
    public bool HasType {
      get { return hasType; }
    }
    public global::Mysqlx.Expr.DocumentPathItem.Types.Type Type {
      get { return type_; }
    }
    
    public const int ValueFieldNumber = 2;
    private bool hasValue;
    private string value_ = "";
    public bool HasValue {
      get { return hasValue; }
    }
    public string Value {
      get { return value_; }
    }
    
    public const int IndexFieldNumber = 3;
    private bool hasIndex;
    private uint index_;
    public bool HasIndex {
      get { return hasIndex; }
    }
    public uint Index {
      get { return index_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasType) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _documentPathItemFieldNames;
      if (hasType) {
        output.WriteEnum(1, field_names[1], (int) Type, Type);
      }
      if (hasValue) {
        output.WriteString(2, field_names[2], Value);
      }
      if (hasIndex) {
        output.WriteUInt32(3, field_names[0], Index);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasType) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Type);
        }
        if (hasValue) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Value);
        }
        if (hasIndex) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, Index);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static DocumentPathItem ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static DocumentPathItem ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static DocumentPathItem ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private DocumentPathItem MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(DocumentPathItem prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<DocumentPathItem, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(DocumentPathItem cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private DocumentPathItem result;
      
      private DocumentPathItem PrepareBuilder() {
        if (resultIsReadOnly) {
          DocumentPathItem original = result;
          result = new DocumentPathItem();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override DocumentPathItem MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.DocumentPathItem.Descriptor; }
      }
      
      public override DocumentPathItem DefaultInstanceForType {
        get { return global::Mysqlx.Expr.DocumentPathItem.DefaultInstance; }
      }
      
      public override DocumentPathItem BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is DocumentPathItem) {
          return MergeFrom((DocumentPathItem) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(DocumentPathItem other) {
        if (other == global::Mysqlx.Expr.DocumentPathItem.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasValue) {
          Value = other.Value;
        }
        if (other.HasIndex) {
          Index = other.Index;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_documentPathItemFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _documentPathItemFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.type_, out unknown)) {
                result.hasType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              result.hasValue = input.ReadString(ref result.value_);
              break;
            }
            case 24: {
              result.hasIndex = input.ReadUInt32(ref result.index_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasType {
       get { return result.hasType; }
      }
      public global::Mysqlx.Expr.DocumentPathItem.Types.Type Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(global::Mysqlx.Expr.DocumentPathItem.Types.Type value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = global::Mysqlx.Expr.DocumentPathItem.Types.Type.MEMBER;
        return this;
      }
      
      public bool HasValue {
        get { return result.hasValue; }
      }
      public string Value {
        get { return result.Value; }
        set { SetValue(value); }
      }
      public Builder SetValue(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasValue = true;
        result.value_ = value;
        return this;
      }
      public Builder ClearValue() {
        PrepareBuilder();
        result.hasValue = false;
        result.value_ = "";
        return this;
      }
      
      public bool HasIndex {
        get { return result.hasIndex; }
      }
      public uint Index {
        get { return result.Index; }
        set { SetIndex(value); }
      }
      public Builder SetIndex(uint value) {
        PrepareBuilder();
        result.hasIndex = true;
        result.index_ = value;
        return this;
      }
      public Builder ClearIndex() {
        PrepareBuilder();
        result.hasIndex = false;
        result.index_ = 0;
        return this;
      }
    }
    static DocumentPathItem() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class ColumnIdentifier : pb::GeneratedMessage<ColumnIdentifier, ColumnIdentifier.Builder> {
    private ColumnIdentifier() { }
    private static readonly ColumnIdentifier defaultInstance = new ColumnIdentifier().MakeReadOnly();
    private static readonly string[] _columnIdentifierFieldNames = new string[] { "document_path", "name", "schema_name", "table_name" };
    private static readonly uint[] _columnIdentifierFieldTags = new uint[] { 10, 18, 34, 26 };
    public static ColumnIdentifier DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ColumnIdentifier DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ColumnIdentifier ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_ColumnIdentifier__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ColumnIdentifier, ColumnIdentifier.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_ColumnIdentifier__FieldAccessorTable; }
    }
    
    public const int DocumentPathFieldNumber = 1;
    private pbc::PopsicleList<global::Mysqlx.Expr.DocumentPathItem> documentPath_ = new pbc::PopsicleList<global::Mysqlx.Expr.DocumentPathItem>();
    public scg::IList<global::Mysqlx.Expr.DocumentPathItem> DocumentPathList {
      get { return documentPath_; }
    }
    public int DocumentPathCount {
      get { return documentPath_.Count; }
    }
    public global::Mysqlx.Expr.DocumentPathItem GetDocumentPath(int index) {
      return documentPath_[index];
    }
    
    public const int NameFieldNumber = 2;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int TableNameFieldNumber = 3;
    private bool hasTableName;
    private string tableName_ = "";
    public bool HasTableName {
      get { return hasTableName; }
    }
    public string TableName {
      get { return tableName_; }
    }
    
    public const int SchemaNameFieldNumber = 4;
    private bool hasSchemaName;
    private string schemaName_ = "";
    public bool HasSchemaName {
      get { return hasSchemaName; }
    }
    public string SchemaName {
      get { return schemaName_; }
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Mysqlx.Expr.DocumentPathItem element in DocumentPathList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _columnIdentifierFieldNames;
      if (documentPath_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], documentPath_);
      }
      if (hasName) {
        output.WriteString(2, field_names[1], Name);
      }
      if (hasTableName) {
        output.WriteString(3, field_names[3], TableName);
      }
      if (hasSchemaName) {
        output.WriteString(4, field_names[2], SchemaName);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::Mysqlx.Expr.DocumentPathItem element in DocumentPathList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Name);
        }
        if (hasTableName) {
          size += pb::CodedOutputStream.ComputeStringSize(3, TableName);
        }
        if (hasSchemaName) {
          size += pb::CodedOutputStream.ComputeStringSize(4, SchemaName);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ColumnIdentifier ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ColumnIdentifier ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ColumnIdentifier ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ColumnIdentifier MakeReadOnly() {
      documentPath_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ColumnIdentifier prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<ColumnIdentifier, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ColumnIdentifier cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ColumnIdentifier result;
      
      private ColumnIdentifier PrepareBuilder() {
        if (resultIsReadOnly) {
          ColumnIdentifier original = result;
          result = new ColumnIdentifier();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ColumnIdentifier MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.ColumnIdentifier.Descriptor; }
      }
      
      public override ColumnIdentifier DefaultInstanceForType {
        get { return global::Mysqlx.Expr.ColumnIdentifier.DefaultInstance; }
      }
      
      public override ColumnIdentifier BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ColumnIdentifier) {
          return MergeFrom((ColumnIdentifier) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ColumnIdentifier other) {
        if (other == global::Mysqlx.Expr.ColumnIdentifier.DefaultInstance) return this;
        PrepareBuilder();
        if (other.documentPath_.Count != 0) {
          result.documentPath_.Add(other.documentPath_);
        }
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasTableName) {
          TableName = other.TableName;
        }
        if (other.HasSchemaName) {
          SchemaName = other.SchemaName;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_columnIdentifierFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _columnIdentifierFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.documentPath_, global::Mysqlx.Expr.DocumentPathItem.DefaultInstance, extensionRegistry);
              break;
            }
            case 18: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 26: {
              result.hasTableName = input.ReadString(ref result.tableName_);
              break;
            }
            case 34: {
              result.hasSchemaName = input.ReadString(ref result.schemaName_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.DocumentPathItem> DocumentPathList {
        get { return PrepareBuilder().documentPath_; }
      }
      public int DocumentPathCount {
        get { return result.DocumentPathCount; }
      }
      public global::Mysqlx.Expr.DocumentPathItem GetDocumentPath(int index) {
        return result.GetDocumentPath(index);
      }
      public Builder SetDocumentPath(int index, global::Mysqlx.Expr.DocumentPathItem value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.documentPath_[index] = value;
        return this;
      }
      public Builder SetDocumentPath(int index, global::Mysqlx.Expr.DocumentPathItem.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.documentPath_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddDocumentPath(global::Mysqlx.Expr.DocumentPathItem value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.documentPath_.Add(value);
        return this;
      }
      public Builder AddDocumentPath(global::Mysqlx.Expr.DocumentPathItem.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.documentPath_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeDocumentPath(scg::IEnumerable<global::Mysqlx.Expr.DocumentPathItem> values) {
        PrepareBuilder();
        result.documentPath_.Add(values);
        return this;
      }
      public Builder ClearDocumentPath() {
        PrepareBuilder();
        result.documentPath_.Clear();
        return this;
      }
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasTableName {
        get { return result.hasTableName; }
      }
      public string TableName {
        get { return result.TableName; }
        set { SetTableName(value); }
      }
      public Builder SetTableName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTableName = true;
        result.tableName_ = value;
        return this;
      }
      public Builder ClearTableName() {
        PrepareBuilder();
        result.hasTableName = false;
        result.tableName_ = "";
        return this;
      }
      
      public bool HasSchemaName {
        get { return result.hasSchemaName; }
      }
      public string SchemaName {
        get { return result.SchemaName; }
        set { SetSchemaName(value); }
      }
      public Builder SetSchemaName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSchemaName = true;
        result.schemaName_ = value;
        return this;
      }
      public Builder ClearSchemaName() {
        PrepareBuilder();
        result.hasSchemaName = false;
        result.schemaName_ = "";
        return this;
      }
    }
    static ColumnIdentifier() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class FunctionCall : pb::GeneratedMessage<FunctionCall, FunctionCall.Builder> {
    private FunctionCall() { }
    private static readonly FunctionCall defaultInstance = new FunctionCall().MakeReadOnly();
    private static readonly string[] _functionCallFieldNames = new string[] { "name", "param" };
    private static readonly uint[] _functionCallFieldTags = new uint[] { 10, 18 };
    public static FunctionCall DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override FunctionCall DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override FunctionCall ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_FunctionCall__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<FunctionCall, FunctionCall.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_FunctionCall__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private global::Mysqlx.Expr.Identifier name_;
    public bool HasName {
      get { return hasName; }
    }
    public global::Mysqlx.Expr.Identifier Name {
      get { return name_ ?? global::Mysqlx.Expr.Identifier.DefaultInstance; }
    }
    
    public const int ParamFieldNumber = 2;
    private pbc::PopsicleList<global::Mysqlx.Expr.Expr> param_ = new pbc::PopsicleList<global::Mysqlx.Expr.Expr>();
    public scg::IList<global::Mysqlx.Expr.Expr> ParamList {
      get { return param_; }
    }
    public int ParamCount {
      get { return param_.Count; }
    }
    public global::Mysqlx.Expr.Expr GetParam(int index) {
      return param_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        if (!Name.IsInitialized) return false;
        foreach (global::Mysqlx.Expr.Expr element in ParamList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _functionCallFieldNames;
      if (hasName) {
        output.WriteMessage(1, field_names[0], Name);
      }
      if (param_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], param_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Name);
        }
        foreach (global::Mysqlx.Expr.Expr element in ParamList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static FunctionCall ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static FunctionCall ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static FunctionCall ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static FunctionCall ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static FunctionCall ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static FunctionCall ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static FunctionCall ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static FunctionCall ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static FunctionCall ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static FunctionCall ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private FunctionCall MakeReadOnly() {
      param_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(FunctionCall prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<FunctionCall, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(FunctionCall cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private FunctionCall result;
      
      private FunctionCall PrepareBuilder() {
        if (resultIsReadOnly) {
          FunctionCall original = result;
          result = new FunctionCall();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override FunctionCall MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.FunctionCall.Descriptor; }
      }
      
      public override FunctionCall DefaultInstanceForType {
        get { return global::Mysqlx.Expr.FunctionCall.DefaultInstance; }
      }
      
      public override FunctionCall BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is FunctionCall) {
          return MergeFrom((FunctionCall) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(FunctionCall other) {
        if (other == global::Mysqlx.Expr.FunctionCall.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          MergeName(other.Name);
        }
        if (other.param_.Count != 0) {
          result.param_.Add(other.param_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_functionCallFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _functionCallFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Mysqlx.Expr.Identifier.Builder subBuilder = global::Mysqlx.Expr.Identifier.CreateBuilder();
              if (result.hasName) {
                subBuilder.MergeFrom(Name);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Name = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.param_, global::Mysqlx.Expr.Expr.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
       get { return result.hasName; }
      }
      public global::Mysqlx.Expr.Identifier Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(global::Mysqlx.Expr.Identifier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder SetName(global::Mysqlx.Expr.Identifier.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = builderForValue.Build();
        return this;
      }
      public Builder MergeName(global::Mysqlx.Expr.Identifier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasName &&
            result.name_ != global::Mysqlx.Expr.Identifier.DefaultInstance) {
            result.name_ = global::Mysqlx.Expr.Identifier.CreateBuilder(result.name_).MergeFrom(value).BuildPartial();
        } else {
          result.name_ = value;
        }
        result.hasName = true;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.Expr> ParamList {
        get { return PrepareBuilder().param_; }
      }
      public int ParamCount {
        get { return result.ParamCount; }
      }
      public global::Mysqlx.Expr.Expr GetParam(int index) {
        return result.GetParam(index);
      }
      public Builder SetParam(int index, global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.param_[index] = value;
        return this;
      }
      public Builder SetParam(int index, global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.param_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddParam(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.param_.Add(value);
        return this;
      }
      public Builder AddParam(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.param_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeParam(scg::IEnumerable<global::Mysqlx.Expr.Expr> values) {
        PrepareBuilder();
        result.param_.Add(values);
        return this;
      }
      public Builder ClearParam() {
        PrepareBuilder();
        result.param_.Clear();
        return this;
      }
    }
    static FunctionCall() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Operator : pb::GeneratedMessage<Operator, Operator.Builder> {
    private Operator() { }
    private static readonly Operator defaultInstance = new Operator().MakeReadOnly();
    private static readonly string[] _operatorFieldNames = new string[] { "name", "param" };
    private static readonly uint[] _operatorFieldTags = new uint[] { 10, 18 };
    public static Operator DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Operator DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Operator ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Operator__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Operator, Operator.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Operator__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int ParamFieldNumber = 2;
    private pbc::PopsicleList<global::Mysqlx.Expr.Expr> param_ = new pbc::PopsicleList<global::Mysqlx.Expr.Expr>();
    public scg::IList<global::Mysqlx.Expr.Expr> ParamList {
      get { return param_; }
    }
    public int ParamCount {
      get { return param_.Count; }
    }
    public global::Mysqlx.Expr.Expr GetParam(int index) {
      return param_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        foreach (global::Mysqlx.Expr.Expr element in ParamList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _operatorFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[0], Name);
      }
      if (param_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], param_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        foreach (global::Mysqlx.Expr.Expr element in ParamList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Operator ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Operator ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Operator ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Operator ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Operator ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Operator ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Operator ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Operator ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Operator ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Operator ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Operator MakeReadOnly() {
      param_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Operator prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Operator, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Operator cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Operator result;
      
      private Operator PrepareBuilder() {
        if (resultIsReadOnly) {
          Operator original = result;
          result = new Operator();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Operator MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.Operator.Descriptor; }
      }
      
      public override Operator DefaultInstanceForType {
        get { return global::Mysqlx.Expr.Operator.DefaultInstance; }
      }
      
      public override Operator BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Operator) {
          return MergeFrom((Operator) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Operator other) {
        if (other == global::Mysqlx.Expr.Operator.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.param_.Count != 0) {
          result.param_.Add(other.param_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_operatorFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _operatorFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.param_, global::Mysqlx.Expr.Expr.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.Expr> ParamList {
        get { return PrepareBuilder().param_; }
      }
      public int ParamCount {
        get { return result.ParamCount; }
      }
      public global::Mysqlx.Expr.Expr GetParam(int index) {
        return result.GetParam(index);
      }
      public Builder SetParam(int index, global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.param_[index] = value;
        return this;
      }
      public Builder SetParam(int index, global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.param_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddParam(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.param_.Add(value);
        return this;
      }
      public Builder AddParam(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.param_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeParam(scg::IEnumerable<global::Mysqlx.Expr.Expr> values) {
        PrepareBuilder();
        result.param_.Add(values);
        return this;
      }
      public Builder ClearParam() {
        PrepareBuilder();
        result.param_.Clear();
        return this;
      }
    }
    static Operator() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
