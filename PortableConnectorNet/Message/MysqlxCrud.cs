// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Mysqlx.Crud {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal static partial class MysqlxCrud {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Column__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Column, global::Mysqlx.Crud.Column.Builder> internal__static_Mysqlx_Crud_Column__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Collection__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Collection, global::Mysqlx.Crud.Collection.Builder> internal__static_Mysqlx_Crud_Collection__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Limit__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Limit, global::Mysqlx.Crud.Limit.Builder> internal__static_Mysqlx_Crud_Limit__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Order__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Order, global::Mysqlx.Crud.Order.Builder> internal__static_Mysqlx_Crud_Order__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_PrepareFind__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.PrepareFind, global::Mysqlx.Crud.PrepareFind.Builder> internal__static_Mysqlx_Crud_PrepareFind__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_PrepareInsert__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.PrepareInsert, global::Mysqlx.Crud.PrepareInsert.Builder> internal__static_Mysqlx_Crud_PrepareInsert__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_PrepareUpdate__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.PrepareUpdate, global::Mysqlx.Crud.PrepareUpdate.Builder> internal__static_Mysqlx_Crud_PrepareUpdate__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_PrepareDelete__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.PrepareDelete, global::Mysqlx.Crud.PrepareDelete.Builder> internal__static_Mysqlx_Crud_PrepareDelete__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Find__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Find, global::Mysqlx.Crud.Find.Builder> internal__static_Mysqlx_Crud_Find__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Insert__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Insert, global::Mysqlx.Crud.Insert.Builder> internal__static_Mysqlx_Crud_Insert__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Update__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Update, global::Mysqlx.Crud.Update.Builder> internal__static_Mysqlx_Crud_Update__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Delete__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Delete, global::Mysqlx.Crud.Delete.Builder> internal__static_Mysqlx_Crud_Delete__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static MysqlxCrud() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "ChFteXNxbHhfY3J1ZC5wcm90bxILTXlzcWx4LkNydWQaEW15c3FseF9leHBy" + 
          "LnByb3RvGhBteXNxbHhfc3FsLnByb3RvIlsKBkNvbHVtbhIMCgRuYW1lGAEg" + 
          "ASgJEg0KBWFsaWFzGAIgASgJEjQKDWRvY3VtZW50X3BhdGgYAyADKAsyHS5N" + 
          "eXNxbHguRXhwci5Eb2N1bWVudFBhdGhJdGVtIioKCkNvbGxlY3Rpb24SDAoE" + 
          "bmFtZRgBIAIoCRIOCgZzY2hlbWEYAiABKAkiJQoFTGltaXQSDAoEc2tpcBgB" + 
          "IAIoBBIOCgZvZmZzZXQYAiABKAQiawoFT3JkZXISDAoEZXhwchgBIAIoCRI0" + 
          "CglkaXJlY3Rpb24YAiABKA4yHC5NeXNxbHguQ3J1ZC5PcmRlci5EaXJlY3Rp" + 
          "b246A0FTQyIeCglEaXJlY3Rpb24SBwoDQVNDEAESCAoEREVTQxACIosCCgtQ" + 
          "cmVwYXJlRmluZBIPCgdzdG10X2lkGAEgAigNEisKCmNvbGxlY3Rpb24YAiAC" + 
          "KAsyFy5NeXNxbHguQ3J1ZC5Db2xsZWN0aW9uEioKCmRhdGFfbW9kZWwYAyAB" + 
          "KA4yFi5NeXNxbHguQ3J1ZC5EYXRhTW9kZWwSJwoKcHJvamVjdGlvbhgEIAMo" + 
          "CzITLk15c3FseC5DcnVkLkNvbHVtbhIjCghjcml0ZXJpYRgFIAEoCzIRLk15" + 
          "c3FseC5FeHByLkV4cHISIQoFbGltaXQYBiABKAsyEi5NeXNxbHguQ3J1ZC5M" + 
          "aW1pdBIhCgVvcmRlchgHIAMoCzISLk15c3FseC5DcnVkLk9yZGVyIqIBCg1Q" + 
          "cmVwYXJlSW5zZXJ0Eg8KB3N0bXRfaWQYASACKA0SKwoKY29sbGVjdGlvbhgC" + 
          "IAIoCzIXLk15c3FseC5DcnVkLkNvbGxlY3Rpb24SKgoKZGF0YV9tb2RlbBgD" + 
          "IAEoDjIWLk15c3FseC5DcnVkLkRhdGFNb2RlbBInCgpwcm9qZWN0aW9uGAQg" + 
          "AygLMhMuTXlzcWx4LkNydWQuQ29sdW1uInkKDVByZXBhcmVVcGRhdGUSDwoH" + 
          "c3RtdF9pZBgBIAIoDRIrCgpjb2xsZWN0aW9uGAIgAigLMhcuTXlzcWx4LkNy" + 
          "dWQuQ29sbGVjdGlvbhIqCgpkYXRhX21vZGVsGAMgASgOMhYuTXlzcWx4LkNy" + 
          "dWQuRGF0YU1vZGVsIuQBCg1QcmVwYXJlRGVsZXRlEg8KB3N0bXRfaWQYASAC" + 
          "KA0SKwoKY29sbGVjdGlvbhgCIAIoCzIXLk15c3FseC5DcnVkLkNvbGxlY3Rp" + 
          "b24SKgoKZGF0YV9tb2RlbBgDIAEoDjIWLk15c3FseC5DcnVkLkRhdGFNb2Rl" + 
          "bBIjCghjcml0ZXJpYRgEIAEoCzIRLk15c3FseC5FeHByLkV4cHISIQoFbGlt" + 
          "aXQYBSABKAsyEi5NeXNxbHguQ3J1ZC5MaW1pdBIhCgVvcmRlchgGIAMoCzIS" + 
          "Lk15c3FseC5DcnVkLk9yZGVyIvMBCgRGaW5kEisKCmNvbGxlY3Rpb24YAiAC" + 
          "KAsyFy5NeXNxbHguQ3J1ZC5Db2xsZWN0aW9uEioKCmRhdGFfbW9kZWwYAyAB" + 
          "KA4yFi5NeXNxbHguQ3J1ZC5EYXRhTW9kZWwSJwoKcHJvamVjdGlvbhgEIAMo" + 
          "CzITLk15c3FseC5DcnVkLkNvbHVtbhIjCghjcml0ZXJpYRgFIAEoCzIRLk15" + 
          "c3FseC5FeHByLkV4cHISIQoFbGltaXQYBiABKAsyEi5NeXNxbHguQ3J1ZC5M" + 
          "aW1pdBIhCgVvcmRlchgHIAMoCzISLk15c3FseC5DcnVkLk9yZGVyIqgBCgZJ" + 
          "bnNlcnQSKwoKY29sbGVjdGlvbhgBIAIoCzIXLk15c3FseC5DcnVkLkNvbGxl" + 
          "Y3Rpb24SKgoKZGF0YV9tb2RlbBgCIAEoDjIWLk15c3FseC5DcnVkLkRhdGFN" + 
          "b2RlbBInCgpwcm9qZWN0aW9uGAMgAygLMhMuTXlzcWx4LkNydWQuQ29sdW1u" + 
          "EhwKA3JvdxgEIAMoCzIPLk15c3FseC5TcWwuUm93ImEKBlVwZGF0ZRIrCgpj" + 
          "b2xsZWN0aW9uGAIgAigLMhcuTXlzcWx4LkNydWQuQ29sbGVjdGlvbhIqCgpk" + 
          "YXRhX21vZGVsGAMgASgOMhYuTXlzcWx4LkNydWQuRGF0YU1vZGVsIswBCgZE" + 
          "ZWxldGUSKwoKY29sbGVjdGlvbhgBIAIoCzIXLk15c3FseC5DcnVkLkNvbGxl" + 
          "Y3Rpb24SKgoKZGF0YV9tb2RlbBgCIAEoDjIWLk15c3FseC5DcnVkLkRhdGFN" + 
          "b2RlbBIjCghjcml0ZXJpYRgDIAEoCzIRLk15c3FseC5FeHByLkV4cHISIQoF" + 
          "bGltaXQYBCABKAsyEi5NeXNxbHguQ3J1ZC5MaW1pdBIhCgVvcmRlchgFIAMo" + 
          "CzISLk15c3FseC5DcnVkLk9yZGVyKiQKCURhdGFNb2RlbBIMCghET0NVTUVO" + 
          "VBABEgkKBVRBQkxFEAI=");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Mysqlx_Crud_Column__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Mysqlx_Crud_Column__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Column, global::Mysqlx.Crud.Column.Builder>(internal__static_Mysqlx_Crud_Column__Descriptor,
                new string[] { "Name", "Alias", "DocumentPath", });
        internal__static_Mysqlx_Crud_Collection__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Mysqlx_Crud_Collection__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Collection, global::Mysqlx.Crud.Collection.Builder>(internal__static_Mysqlx_Crud_Collection__Descriptor,
                new string[] { "Name", "Schema", });
        internal__static_Mysqlx_Crud_Limit__Descriptor = Descriptor.MessageTypes[2];
        internal__static_Mysqlx_Crud_Limit__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Limit, global::Mysqlx.Crud.Limit.Builder>(internal__static_Mysqlx_Crud_Limit__Descriptor,
                new string[] { "Skip", "Offset", });
        internal__static_Mysqlx_Crud_Order__Descriptor = Descriptor.MessageTypes[3];
        internal__static_Mysqlx_Crud_Order__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Order, global::Mysqlx.Crud.Order.Builder>(internal__static_Mysqlx_Crud_Order__Descriptor,
                new string[] { "Expr", "Direction", });
        internal__static_Mysqlx_Crud_PrepareFind__Descriptor = Descriptor.MessageTypes[4];
        internal__static_Mysqlx_Crud_PrepareFind__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.PrepareFind, global::Mysqlx.Crud.PrepareFind.Builder>(internal__static_Mysqlx_Crud_PrepareFind__Descriptor,
                new string[] { "StmtId", "Collection", "DataModel", "Projection", "Criteria", "Limit", "Order", });
        internal__static_Mysqlx_Crud_PrepareInsert__Descriptor = Descriptor.MessageTypes[5];
        internal__static_Mysqlx_Crud_PrepareInsert__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.PrepareInsert, global::Mysqlx.Crud.PrepareInsert.Builder>(internal__static_Mysqlx_Crud_PrepareInsert__Descriptor,
                new string[] { "StmtId", "Collection", "DataModel", "Projection", });
        internal__static_Mysqlx_Crud_PrepareUpdate__Descriptor = Descriptor.MessageTypes[6];
        internal__static_Mysqlx_Crud_PrepareUpdate__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.PrepareUpdate, global::Mysqlx.Crud.PrepareUpdate.Builder>(internal__static_Mysqlx_Crud_PrepareUpdate__Descriptor,
                new string[] { "StmtId", "Collection", "DataModel", });
        internal__static_Mysqlx_Crud_PrepareDelete__Descriptor = Descriptor.MessageTypes[7];
        internal__static_Mysqlx_Crud_PrepareDelete__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.PrepareDelete, global::Mysqlx.Crud.PrepareDelete.Builder>(internal__static_Mysqlx_Crud_PrepareDelete__Descriptor,
                new string[] { "StmtId", "Collection", "DataModel", "Criteria", "Limit", "Order", });
        internal__static_Mysqlx_Crud_Find__Descriptor = Descriptor.MessageTypes[8];
        internal__static_Mysqlx_Crud_Find__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Find, global::Mysqlx.Crud.Find.Builder>(internal__static_Mysqlx_Crud_Find__Descriptor,
                new string[] { "Collection", "DataModel", "Projection", "Criteria", "Limit", "Order", });
        internal__static_Mysqlx_Crud_Insert__Descriptor = Descriptor.MessageTypes[9];
        internal__static_Mysqlx_Crud_Insert__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Insert, global::Mysqlx.Crud.Insert.Builder>(internal__static_Mysqlx_Crud_Insert__Descriptor,
                new string[] { "Collection", "DataModel", "Projection", "Row", });
        internal__static_Mysqlx_Crud_Update__Descriptor = Descriptor.MessageTypes[10];
        internal__static_Mysqlx_Crud_Update__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Update, global::Mysqlx.Crud.Update.Builder>(internal__static_Mysqlx_Crud_Update__Descriptor,
                new string[] { "Collection", "DataModel", });
        internal__static_Mysqlx_Crud_Delete__Descriptor = Descriptor.MessageTypes[11];
        internal__static_Mysqlx_Crud_Delete__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Delete, global::Mysqlx.Crud.Delete.Builder>(internal__static_Mysqlx_Crud_Delete__Descriptor,
                new string[] { "Collection", "DataModel", "Criteria", "Limit", "Order", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          global::Mysqlx.Expr.MysqlxExpr.Descriptor, 
          global::Mysqlx.Sql.MysqlxSql.Descriptor, 
          }, assigner);
    }
    #endregion
    
  }
  #region Enums
  internal enum DataModel {
    DOCUMENT = 1,
    TABLE = 2,
  }
  
  #endregion
  
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Column : pb::GeneratedMessage<Column, Column.Builder> {
    private Column() { }
    private static readonly Column defaultInstance = new Column().MakeReadOnly();
    private static readonly string[] _columnFieldNames = new string[] { "alias", "document_path", "name" };
    private static readonly uint[] _columnFieldTags = new uint[] { 18, 26, 10 };
    public static Column DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Column DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Column ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Column__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Column, Column.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Column__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int AliasFieldNumber = 2;
    private bool hasAlias;
    private string alias_ = "";
    public bool HasAlias {
      get { return hasAlias; }
    }
    public string Alias {
      get { return alias_; }
    }
    
    public const int DocumentPathFieldNumber = 3;
    private pbc::PopsicleList<global::Mysqlx.Expr.DocumentPathItem> documentPath_ = new pbc::PopsicleList<global::Mysqlx.Expr.DocumentPathItem>();
    public scg::IList<global::Mysqlx.Expr.DocumentPathItem> DocumentPathList {
      get { return documentPath_; }
    }
    public int DocumentPathCount {
      get { return documentPath_.Count; }
    }
    public global::Mysqlx.Expr.DocumentPathItem GetDocumentPath(int index) {
      return documentPath_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Mysqlx.Expr.DocumentPathItem element in DocumentPathList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _columnFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[2], Name);
      }
      if (hasAlias) {
        output.WriteString(2, field_names[0], Alias);
      }
      if (documentPath_.Count > 0) {
        output.WriteMessageArray(3, field_names[1], documentPath_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasAlias) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Alias);
        }
        foreach (global::Mysqlx.Expr.DocumentPathItem element in DocumentPathList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Column ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Column ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Column ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Column ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Column ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Column ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Column ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Column ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Column ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Column ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Column MakeReadOnly() {
      documentPath_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Column prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Column, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Column cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Column result;
      
      private Column PrepareBuilder() {
        if (resultIsReadOnly) {
          Column original = result;
          result = new Column();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Column MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Column.Descriptor; }
      }
      
      public override Column DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Column.DefaultInstance; }
      }
      
      public override Column BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Column) {
          return MergeFrom((Column) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Column other) {
        if (other == global::Mysqlx.Crud.Column.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasAlias) {
          Alias = other.Alias;
        }
        if (other.documentPath_.Count != 0) {
          result.documentPath_.Add(other.documentPath_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_columnFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _columnFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              result.hasAlias = input.ReadString(ref result.alias_);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.documentPath_, global::Mysqlx.Expr.DocumentPathItem.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasAlias {
        get { return result.hasAlias; }
      }
      public string Alias {
        get { return result.Alias; }
        set { SetAlias(value); }
      }
      public Builder SetAlias(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAlias = true;
        result.alias_ = value;
        return this;
      }
      public Builder ClearAlias() {
        PrepareBuilder();
        result.hasAlias = false;
        result.alias_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.DocumentPathItem> DocumentPathList {
        get { return PrepareBuilder().documentPath_; }
      }
      public int DocumentPathCount {
        get { return result.DocumentPathCount; }
      }
      public global::Mysqlx.Expr.DocumentPathItem GetDocumentPath(int index) {
        return result.GetDocumentPath(index);
      }
      public Builder SetDocumentPath(int index, global::Mysqlx.Expr.DocumentPathItem value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.documentPath_[index] = value;
        return this;
      }
      public Builder SetDocumentPath(int index, global::Mysqlx.Expr.DocumentPathItem.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.documentPath_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddDocumentPath(global::Mysqlx.Expr.DocumentPathItem value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.documentPath_.Add(value);
        return this;
      }
      public Builder AddDocumentPath(global::Mysqlx.Expr.DocumentPathItem.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.documentPath_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeDocumentPath(scg::IEnumerable<global::Mysqlx.Expr.DocumentPathItem> values) {
        PrepareBuilder();
        result.documentPath_.Add(values);
        return this;
      }
      public Builder ClearDocumentPath() {
        PrepareBuilder();
        result.documentPath_.Clear();
        return this;
      }
    }
    static Column() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Collection : pb::GeneratedMessage<Collection, Collection.Builder> {
    private Collection() { }
    private static readonly Collection defaultInstance = new Collection().MakeReadOnly();
    private static readonly string[] _collectionFieldNames = new string[] { "name", "schema" };
    private static readonly uint[] _collectionFieldTags = new uint[] { 10, 18 };
    public static Collection DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Collection DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Collection ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Collection__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Collection, Collection.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Collection__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int SchemaFieldNumber = 2;
    private bool hasSchema;
    private string schema_ = "";
    public bool HasSchema {
      get { return hasSchema; }
    }
    public string Schema {
      get { return schema_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _collectionFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[0], Name);
      }
      if (hasSchema) {
        output.WriteString(2, field_names[1], Schema);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasSchema) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Schema);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Collection ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Collection ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Collection ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Collection ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Collection ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Collection ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Collection ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Collection ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Collection ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Collection ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Collection MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Collection prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Collection, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Collection cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Collection result;
      
      private Collection PrepareBuilder() {
        if (resultIsReadOnly) {
          Collection original = result;
          result = new Collection();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Collection MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Collection.Descriptor; }
      }
      
      public override Collection DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Collection.DefaultInstance; }
      }
      
      public override Collection BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Collection) {
          return MergeFrom((Collection) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Collection other) {
        if (other == global::Mysqlx.Crud.Collection.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasSchema) {
          Schema = other.Schema;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_collectionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _collectionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              result.hasSchema = input.ReadString(ref result.schema_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasSchema {
        get { return result.hasSchema; }
      }
      public string Schema {
        get { return result.Schema; }
        set { SetSchema(value); }
      }
      public Builder SetSchema(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSchema = true;
        result.schema_ = value;
        return this;
      }
      public Builder ClearSchema() {
        PrepareBuilder();
        result.hasSchema = false;
        result.schema_ = "";
        return this;
      }
    }
    static Collection() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Limit : pb::GeneratedMessage<Limit, Limit.Builder> {
    private Limit() { }
    private static readonly Limit defaultInstance = new Limit().MakeReadOnly();
    private static readonly string[] _limitFieldNames = new string[] { "offset", "skip" };
    private static readonly uint[] _limitFieldTags = new uint[] { 16, 8 };
    public static Limit DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Limit DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Limit ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Limit__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Limit, Limit.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Limit__FieldAccessorTable; }
    }
    
    public const int SkipFieldNumber = 1;
    private bool hasSkip;
    private ulong skip_;
    public bool HasSkip {
      get { return hasSkip; }
    }
    public ulong Skip {
      get { return skip_; }
    }
    
    public const int OffsetFieldNumber = 2;
    private bool hasOffset;
    private ulong offset_;
    public bool HasOffset {
      get { return hasOffset; }
    }
    public ulong Offset {
      get { return offset_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSkip) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _limitFieldNames;
      if (hasSkip) {
        output.WriteUInt64(1, field_names[1], Skip);
      }
      if (hasOffset) {
        output.WriteUInt64(2, field_names[0], Offset);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasSkip) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, Skip);
        }
        if (hasOffset) {
          size += pb::CodedOutputStream.ComputeUInt64Size(2, Offset);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Limit ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Limit ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Limit ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Limit ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Limit ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Limit ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Limit ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Limit ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Limit ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Limit ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Limit MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Limit prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Limit, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Limit cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Limit result;
      
      private Limit PrepareBuilder() {
        if (resultIsReadOnly) {
          Limit original = result;
          result = new Limit();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Limit MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Limit.Descriptor; }
      }
      
      public override Limit DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Limit.DefaultInstance; }
      }
      
      public override Limit BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Limit) {
          return MergeFrom((Limit) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Limit other) {
        if (other == global::Mysqlx.Crud.Limit.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSkip) {
          Skip = other.Skip;
        }
        if (other.HasOffset) {
          Offset = other.Offset;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_limitFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _limitFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasSkip = input.ReadUInt64(ref result.skip_);
              break;
            }
            case 16: {
              result.hasOffset = input.ReadUInt64(ref result.offset_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSkip {
        get { return result.hasSkip; }
      }
      public ulong Skip {
        get { return result.Skip; }
        set { SetSkip(value); }
      }
      public Builder SetSkip(ulong value) {
        PrepareBuilder();
        result.hasSkip = true;
        result.skip_ = value;
        return this;
      }
      public Builder ClearSkip() {
        PrepareBuilder();
        result.hasSkip = false;
        result.skip_ = 0UL;
        return this;
      }
      
      public bool HasOffset {
        get { return result.hasOffset; }
      }
      public ulong Offset {
        get { return result.Offset; }
        set { SetOffset(value); }
      }
      public Builder SetOffset(ulong value) {
        PrepareBuilder();
        result.hasOffset = true;
        result.offset_ = value;
        return this;
      }
      public Builder ClearOffset() {
        PrepareBuilder();
        result.hasOffset = false;
        result.offset_ = 0UL;
        return this;
      }
    }
    static Limit() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Order : pb::GeneratedMessage<Order, Order.Builder> {
    private Order() { }
    private static readonly Order defaultInstance = new Order().MakeReadOnly();
    private static readonly string[] _orderFieldNames = new string[] { "direction", "expr" };
    private static readonly uint[] _orderFieldTags = new uint[] { 16, 10 };
    public static Order DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Order DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Order ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Order__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Order, Order.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Order__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      internal enum Direction {
        ASC = 1,
        DESC = 2,
      }
      
    }
    #endregion
    
    public const int ExprFieldNumber = 1;
    private bool hasExpr;
    private string expr_ = "";
    public bool HasExpr {
      get { return hasExpr; }
    }
    public string Expr {
      get { return expr_; }
    }
    
    public const int DirectionFieldNumber = 2;
    private bool hasDirection;
    private global::Mysqlx.Crud.Order.Types.Direction direction_ = global::Mysqlx.Crud.Order.Types.Direction.ASC;
    public bool HasDirection {
      get { return hasDirection; }
    }
    public global::Mysqlx.Crud.Order.Types.Direction Direction {
      get { return direction_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasExpr) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _orderFieldNames;
      if (hasExpr) {
        output.WriteString(1, field_names[1], Expr);
      }
      if (hasDirection) {
        output.WriteEnum(2, field_names[0], (int) Direction, Direction);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasExpr) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Expr);
        }
        if (hasDirection) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Direction);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Order ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Order ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Order ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Order ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Order ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Order ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Order ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Order ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Order ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Order ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Order MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Order prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Order, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Order cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Order result;
      
      private Order PrepareBuilder() {
        if (resultIsReadOnly) {
          Order original = result;
          result = new Order();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Order MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Order.Descriptor; }
      }
      
      public override Order DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Order.DefaultInstance; }
      }
      
      public override Order BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Order) {
          return MergeFrom((Order) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Order other) {
        if (other == global::Mysqlx.Crud.Order.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasExpr) {
          Expr = other.Expr;
        }
        if (other.HasDirection) {
          Direction = other.Direction;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_orderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _orderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasExpr = input.ReadString(ref result.expr_);
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.direction_, out unknown)) {
                result.hasDirection = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasExpr {
        get { return result.hasExpr; }
      }
      public string Expr {
        get { return result.Expr; }
        set { SetExpr(value); }
      }
      public Builder SetExpr(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasExpr = true;
        result.expr_ = value;
        return this;
      }
      public Builder ClearExpr() {
        PrepareBuilder();
        result.hasExpr = false;
        result.expr_ = "";
        return this;
      }
      
      public bool HasDirection {
       get { return result.hasDirection; }
      }
      public global::Mysqlx.Crud.Order.Types.Direction Direction {
        get { return result.Direction; }
        set { SetDirection(value); }
      }
      public Builder SetDirection(global::Mysqlx.Crud.Order.Types.Direction value) {
        PrepareBuilder();
        result.hasDirection = true;
        result.direction_ = value;
        return this;
      }
      public Builder ClearDirection() {
        PrepareBuilder();
        result.hasDirection = false;
        result.direction_ = global::Mysqlx.Crud.Order.Types.Direction.ASC;
        return this;
      }
    }
    static Order() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class PrepareFind : pb::GeneratedMessage<PrepareFind, PrepareFind.Builder> {
    private PrepareFind() { }
    private static readonly PrepareFind defaultInstance = new PrepareFind().MakeReadOnly();
    private static readonly string[] _prepareFindFieldNames = new string[] { "collection", "criteria", "data_model", "limit", "order", "projection", "stmt_id" };
    private static readonly uint[] _prepareFindFieldTags = new uint[] { 18, 42, 24, 50, 58, 34, 8 };
    public static PrepareFind DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PrepareFind DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PrepareFind ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_PrepareFind__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PrepareFind, PrepareFind.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_PrepareFind__FieldAccessorTable; }
    }
    
    public const int StmtIdFieldNumber = 1;
    private bool hasStmtId;
    private uint stmtId_;
    public bool HasStmtId {
      get { return hasStmtId; }
    }
    public uint StmtId {
      get { return stmtId_; }
    }
    
    public const int CollectionFieldNumber = 2;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 3;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public const int ProjectionFieldNumber = 4;
    private pbc::PopsicleList<global::Mysqlx.Crud.Column> projection_ = new pbc::PopsicleList<global::Mysqlx.Crud.Column>();
    public scg::IList<global::Mysqlx.Crud.Column> ProjectionList {
      get { return projection_; }
    }
    public int ProjectionCount {
      get { return projection_.Count; }
    }
    public global::Mysqlx.Crud.Column GetProjection(int index) {
      return projection_[index];
    }
    
    public const int CriteriaFieldNumber = 5;
    private bool hasCriteria;
    private global::Mysqlx.Expr.Expr criteria_;
    public bool HasCriteria {
      get { return hasCriteria; }
    }
    public global::Mysqlx.Expr.Expr Criteria {
      get { return criteria_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public const int LimitFieldNumber = 6;
    private bool hasLimit;
    private global::Mysqlx.Crud.Limit limit_;
    public bool HasLimit {
      get { return hasLimit; }
    }
    public global::Mysqlx.Crud.Limit Limit {
      get { return limit_ ?? global::Mysqlx.Crud.Limit.DefaultInstance; }
    }
    
    public const int OrderFieldNumber = 7;
    private pbc::PopsicleList<global::Mysqlx.Crud.Order> order_ = new pbc::PopsicleList<global::Mysqlx.Crud.Order>();
    public scg::IList<global::Mysqlx.Crud.Order> OrderList {
      get { return order_; }
    }
    public int OrderCount {
      get { return order_.Count; }
    }
    public global::Mysqlx.Crud.Order GetOrder(int index) {
      return order_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasStmtId) return false;
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        foreach (global::Mysqlx.Crud.Column element in ProjectionList) {
          if (!element.IsInitialized) return false;
        }
        if (HasCriteria) {
          if (!Criteria.IsInitialized) return false;
        }
        if (HasLimit) {
          if (!Limit.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _prepareFindFieldNames;
      if (hasStmtId) {
        output.WriteUInt32(1, field_names[6], StmtId);
      }
      if (hasCollection) {
        output.WriteMessage(2, field_names[0], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(3, field_names[2], (int) DataModel, DataModel);
      }
      if (projection_.Count > 0) {
        output.WriteMessageArray(4, field_names[5], projection_);
      }
      if (hasCriteria) {
        output.WriteMessage(5, field_names[1], Criteria);
      }
      if (hasLimit) {
        output.WriteMessage(6, field_names[3], Limit);
      }
      if (order_.Count > 0) {
        output.WriteMessageArray(7, field_names[4], order_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasStmtId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, StmtId);
        }
        if (hasCollection) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Collection);
        }
        if (hasDataModel) {
          size += pb::CodedOutputStream.ComputeEnumSize(3, (int) DataModel);
        }
        foreach (global::Mysqlx.Crud.Column element in ProjectionList) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, element);
        }
        if (hasCriteria) {
          size += pb::CodedOutputStream.ComputeMessageSize(5, Criteria);
        }
        if (hasLimit) {
          size += pb::CodedOutputStream.ComputeMessageSize(6, Limit);
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          size += pb::CodedOutputStream.ComputeMessageSize(7, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PrepareFind ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PrepareFind ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PrepareFind ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PrepareFind ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PrepareFind ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PrepareFind ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PrepareFind ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PrepareFind ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PrepareFind ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PrepareFind ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PrepareFind MakeReadOnly() {
      projection_.MakeReadOnly();
      order_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PrepareFind prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<PrepareFind, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PrepareFind cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PrepareFind result;
      
      private PrepareFind PrepareBuilder() {
        if (resultIsReadOnly) {
          PrepareFind original = result;
          result = new PrepareFind();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PrepareFind MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.PrepareFind.Descriptor; }
      }
      
      public override PrepareFind DefaultInstanceForType {
        get { return global::Mysqlx.Crud.PrepareFind.DefaultInstance; }
      }
      
      public override PrepareFind BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PrepareFind) {
          return MergeFrom((PrepareFind) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PrepareFind other) {
        if (other == global::Mysqlx.Crud.PrepareFind.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStmtId) {
          StmtId = other.StmtId;
        }
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        if (other.projection_.Count != 0) {
          result.projection_.Add(other.projection_);
        }
        if (other.HasCriteria) {
          MergeCriteria(other.Criteria);
        }
        if (other.HasLimit) {
          MergeLimit(other.Limit);
        }
        if (other.order_.Count != 0) {
          result.order_.Add(other.order_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_prepareFindFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _prepareFindFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStmtId = input.ReadUInt32(ref result.stmtId_);
              break;
            }
            case 18: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
            case 34: {
              input.ReadMessageArray(tag, field_name, result.projection_, global::Mysqlx.Crud.Column.DefaultInstance, extensionRegistry);
              break;
            }
            case 42: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasCriteria) {
                subBuilder.MergeFrom(Criteria);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Criteria = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              global::Mysqlx.Crud.Limit.Builder subBuilder = global::Mysqlx.Crud.Limit.CreateBuilder();
              if (result.hasLimit) {
                subBuilder.MergeFrom(Limit);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Limit = subBuilder.BuildPartial();
              break;
            }
            case 58: {
              input.ReadMessageArray(tag, field_name, result.order_, global::Mysqlx.Crud.Order.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStmtId {
        get { return result.hasStmtId; }
      }
      public uint StmtId {
        get { return result.StmtId; }
        set { SetStmtId(value); }
      }
      public Builder SetStmtId(uint value) {
        PrepareBuilder();
        result.hasStmtId = true;
        result.stmtId_ = value;
        return this;
      }
      public Builder ClearStmtId() {
        PrepareBuilder();
        result.hasStmtId = false;
        result.stmtId_ = 0;
        return this;
      }
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Column> ProjectionList {
        get { return PrepareBuilder().projection_; }
      }
      public int ProjectionCount {
        get { return result.ProjectionCount; }
      }
      public global::Mysqlx.Crud.Column GetProjection(int index) {
        return result.GetProjection(index);
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Column value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_[index] = value;
        return this;
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Column.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Column value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_.Add(value);
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Column.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeProjection(scg::IEnumerable<global::Mysqlx.Crud.Column> values) {
        PrepareBuilder();
        result.projection_.Add(values);
        return this;
      }
      public Builder ClearProjection() {
        PrepareBuilder();
        result.projection_.Clear();
        return this;
      }
      
      public bool HasCriteria {
       get { return result.hasCriteria; }
      }
      public global::Mysqlx.Expr.Expr Criteria {
        get { return result.Criteria; }
        set { SetCriteria(value); }
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = value;
        return this;
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCriteria &&
            result.criteria_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.criteria_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.criteria_).MergeFrom(value).BuildPartial();
        } else {
          result.criteria_ = value;
        }
        result.hasCriteria = true;
        return this;
      }
      public Builder ClearCriteria() {
        PrepareBuilder();
        result.hasCriteria = false;
        result.criteria_ = null;
        return this;
      }
      
      public bool HasLimit {
       get { return result.hasLimit; }
      }
      public global::Mysqlx.Crud.Limit Limit {
        get { return result.Limit; }
        set { SetLimit(value); }
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = value;
        return this;
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLimit &&
            result.limit_ != global::Mysqlx.Crud.Limit.DefaultInstance) {
            result.limit_ = global::Mysqlx.Crud.Limit.CreateBuilder(result.limit_).MergeFrom(value).BuildPartial();
        } else {
          result.limit_ = value;
        }
        result.hasLimit = true;
        return this;
      }
      public Builder ClearLimit() {
        PrepareBuilder();
        result.hasLimit = false;
        result.limit_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Order> OrderList {
        get { return PrepareBuilder().order_; }
      }
      public int OrderCount {
        get { return result.OrderCount; }
      }
      public global::Mysqlx.Crud.Order GetOrder(int index) {
        return result.GetOrder(index);
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_[index] = value;
        return this;
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_.Add(value);
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeOrder(scg::IEnumerable<global::Mysqlx.Crud.Order> values) {
        PrepareBuilder();
        result.order_.Add(values);
        return this;
      }
      public Builder ClearOrder() {
        PrepareBuilder();
        result.order_.Clear();
        return this;
      }
    }
    static PrepareFind() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class PrepareInsert : pb::GeneratedMessage<PrepareInsert, PrepareInsert.Builder> {
    private PrepareInsert() { }
    private static readonly PrepareInsert defaultInstance = new PrepareInsert().MakeReadOnly();
    private static readonly string[] _prepareInsertFieldNames = new string[] { "collection", "data_model", "projection", "stmt_id" };
    private static readonly uint[] _prepareInsertFieldTags = new uint[] { 18, 24, 34, 8 };
    public static PrepareInsert DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PrepareInsert DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PrepareInsert ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_PrepareInsert__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PrepareInsert, PrepareInsert.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_PrepareInsert__FieldAccessorTable; }
    }
    
    public const int StmtIdFieldNumber = 1;
    private bool hasStmtId;
    private uint stmtId_;
    public bool HasStmtId {
      get { return hasStmtId; }
    }
    public uint StmtId {
      get { return stmtId_; }
    }
    
    public const int CollectionFieldNumber = 2;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 3;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public const int ProjectionFieldNumber = 4;
    private pbc::PopsicleList<global::Mysqlx.Crud.Column> projection_ = new pbc::PopsicleList<global::Mysqlx.Crud.Column>();
    public scg::IList<global::Mysqlx.Crud.Column> ProjectionList {
      get { return projection_; }
    }
    public int ProjectionCount {
      get { return projection_.Count; }
    }
    public global::Mysqlx.Crud.Column GetProjection(int index) {
      return projection_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasStmtId) return false;
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        foreach (global::Mysqlx.Crud.Column element in ProjectionList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _prepareInsertFieldNames;
      if (hasStmtId) {
        output.WriteUInt32(1, field_names[3], StmtId);
      }
      if (hasCollection) {
        output.WriteMessage(2, field_names[0], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(3, field_names[1], (int) DataModel, DataModel);
      }
      if (projection_.Count > 0) {
        output.WriteMessageArray(4, field_names[2], projection_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasStmtId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, StmtId);
        }
        if (hasCollection) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Collection);
        }
        if (hasDataModel) {
          size += pb::CodedOutputStream.ComputeEnumSize(3, (int) DataModel);
        }
        foreach (global::Mysqlx.Crud.Column element in ProjectionList) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PrepareInsert ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PrepareInsert ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PrepareInsert ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PrepareInsert ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PrepareInsert ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PrepareInsert ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PrepareInsert ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PrepareInsert ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PrepareInsert ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PrepareInsert ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PrepareInsert MakeReadOnly() {
      projection_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PrepareInsert prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<PrepareInsert, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PrepareInsert cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PrepareInsert result;
      
      private PrepareInsert PrepareBuilder() {
        if (resultIsReadOnly) {
          PrepareInsert original = result;
          result = new PrepareInsert();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PrepareInsert MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.PrepareInsert.Descriptor; }
      }
      
      public override PrepareInsert DefaultInstanceForType {
        get { return global::Mysqlx.Crud.PrepareInsert.DefaultInstance; }
      }
      
      public override PrepareInsert BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PrepareInsert) {
          return MergeFrom((PrepareInsert) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PrepareInsert other) {
        if (other == global::Mysqlx.Crud.PrepareInsert.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStmtId) {
          StmtId = other.StmtId;
        }
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        if (other.projection_.Count != 0) {
          result.projection_.Add(other.projection_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_prepareInsertFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _prepareInsertFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStmtId = input.ReadUInt32(ref result.stmtId_);
              break;
            }
            case 18: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
            case 34: {
              input.ReadMessageArray(tag, field_name, result.projection_, global::Mysqlx.Crud.Column.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStmtId {
        get { return result.hasStmtId; }
      }
      public uint StmtId {
        get { return result.StmtId; }
        set { SetStmtId(value); }
      }
      public Builder SetStmtId(uint value) {
        PrepareBuilder();
        result.hasStmtId = true;
        result.stmtId_ = value;
        return this;
      }
      public Builder ClearStmtId() {
        PrepareBuilder();
        result.hasStmtId = false;
        result.stmtId_ = 0;
        return this;
      }
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Column> ProjectionList {
        get { return PrepareBuilder().projection_; }
      }
      public int ProjectionCount {
        get { return result.ProjectionCount; }
      }
      public global::Mysqlx.Crud.Column GetProjection(int index) {
        return result.GetProjection(index);
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Column value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_[index] = value;
        return this;
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Column.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Column value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_.Add(value);
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Column.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeProjection(scg::IEnumerable<global::Mysqlx.Crud.Column> values) {
        PrepareBuilder();
        result.projection_.Add(values);
        return this;
      }
      public Builder ClearProjection() {
        PrepareBuilder();
        result.projection_.Clear();
        return this;
      }
    }
    static PrepareInsert() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class PrepareUpdate : pb::GeneratedMessage<PrepareUpdate, PrepareUpdate.Builder> {
    private PrepareUpdate() { }
    private static readonly PrepareUpdate defaultInstance = new PrepareUpdate().MakeReadOnly();
    private static readonly string[] _prepareUpdateFieldNames = new string[] { "collection", "data_model", "stmt_id" };
    private static readonly uint[] _prepareUpdateFieldTags = new uint[] { 18, 24, 8 };
    public static PrepareUpdate DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PrepareUpdate DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PrepareUpdate ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_PrepareUpdate__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PrepareUpdate, PrepareUpdate.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_PrepareUpdate__FieldAccessorTable; }
    }
    
    public const int StmtIdFieldNumber = 1;
    private bool hasStmtId;
    private uint stmtId_;
    public bool HasStmtId {
      get { return hasStmtId; }
    }
    public uint StmtId {
      get { return stmtId_; }
    }
    
    public const int CollectionFieldNumber = 2;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 3;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasStmtId) return false;
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _prepareUpdateFieldNames;
      if (hasStmtId) {
        output.WriteUInt32(1, field_names[2], StmtId);
      }
      if (hasCollection) {
        output.WriteMessage(2, field_names[0], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(3, field_names[1], (int) DataModel, DataModel);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasStmtId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, StmtId);
        }
        if (hasCollection) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Collection);
        }
        if (hasDataModel) {
          size += pb::CodedOutputStream.ComputeEnumSize(3, (int) DataModel);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PrepareUpdate ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PrepareUpdate ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PrepareUpdate ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PrepareUpdate ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PrepareUpdate ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PrepareUpdate ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PrepareUpdate ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PrepareUpdate ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PrepareUpdate ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PrepareUpdate ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PrepareUpdate MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PrepareUpdate prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<PrepareUpdate, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PrepareUpdate cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PrepareUpdate result;
      
      private PrepareUpdate PrepareBuilder() {
        if (resultIsReadOnly) {
          PrepareUpdate original = result;
          result = new PrepareUpdate();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PrepareUpdate MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.PrepareUpdate.Descriptor; }
      }
      
      public override PrepareUpdate DefaultInstanceForType {
        get { return global::Mysqlx.Crud.PrepareUpdate.DefaultInstance; }
      }
      
      public override PrepareUpdate BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PrepareUpdate) {
          return MergeFrom((PrepareUpdate) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PrepareUpdate other) {
        if (other == global::Mysqlx.Crud.PrepareUpdate.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStmtId) {
          StmtId = other.StmtId;
        }
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_prepareUpdateFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _prepareUpdateFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStmtId = input.ReadUInt32(ref result.stmtId_);
              break;
            }
            case 18: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStmtId {
        get { return result.hasStmtId; }
      }
      public uint StmtId {
        get { return result.StmtId; }
        set { SetStmtId(value); }
      }
      public Builder SetStmtId(uint value) {
        PrepareBuilder();
        result.hasStmtId = true;
        result.stmtId_ = value;
        return this;
      }
      public Builder ClearStmtId() {
        PrepareBuilder();
        result.hasStmtId = false;
        result.stmtId_ = 0;
        return this;
      }
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
    }
    static PrepareUpdate() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class PrepareDelete : pb::GeneratedMessage<PrepareDelete, PrepareDelete.Builder> {
    private PrepareDelete() { }
    private static readonly PrepareDelete defaultInstance = new PrepareDelete().MakeReadOnly();
    private static readonly string[] _prepareDeleteFieldNames = new string[] { "collection", "criteria", "data_model", "limit", "order", "stmt_id" };
    private static readonly uint[] _prepareDeleteFieldTags = new uint[] { 18, 34, 24, 42, 50, 8 };
    public static PrepareDelete DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PrepareDelete DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PrepareDelete ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_PrepareDelete__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PrepareDelete, PrepareDelete.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_PrepareDelete__FieldAccessorTable; }
    }
    
    public const int StmtIdFieldNumber = 1;
    private bool hasStmtId;
    private uint stmtId_;
    public bool HasStmtId {
      get { return hasStmtId; }
    }
    public uint StmtId {
      get { return stmtId_; }
    }
    
    public const int CollectionFieldNumber = 2;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 3;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public const int CriteriaFieldNumber = 4;
    private bool hasCriteria;
    private global::Mysqlx.Expr.Expr criteria_;
    public bool HasCriteria {
      get { return hasCriteria; }
    }
    public global::Mysqlx.Expr.Expr Criteria {
      get { return criteria_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public const int LimitFieldNumber = 5;
    private bool hasLimit;
    private global::Mysqlx.Crud.Limit limit_;
    public bool HasLimit {
      get { return hasLimit; }
    }
    public global::Mysqlx.Crud.Limit Limit {
      get { return limit_ ?? global::Mysqlx.Crud.Limit.DefaultInstance; }
    }
    
    public const int OrderFieldNumber = 6;
    private pbc::PopsicleList<global::Mysqlx.Crud.Order> order_ = new pbc::PopsicleList<global::Mysqlx.Crud.Order>();
    public scg::IList<global::Mysqlx.Crud.Order> OrderList {
      get { return order_; }
    }
    public int OrderCount {
      get { return order_.Count; }
    }
    public global::Mysqlx.Crud.Order GetOrder(int index) {
      return order_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasStmtId) return false;
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        if (HasCriteria) {
          if (!Criteria.IsInitialized) return false;
        }
        if (HasLimit) {
          if (!Limit.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _prepareDeleteFieldNames;
      if (hasStmtId) {
        output.WriteUInt32(1, field_names[5], StmtId);
      }
      if (hasCollection) {
        output.WriteMessage(2, field_names[0], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(3, field_names[2], (int) DataModel, DataModel);
      }
      if (hasCriteria) {
        output.WriteMessage(4, field_names[1], Criteria);
      }
      if (hasLimit) {
        output.WriteMessage(5, field_names[3], Limit);
      }
      if (order_.Count > 0) {
        output.WriteMessageArray(6, field_names[4], order_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasStmtId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, StmtId);
        }
        if (hasCollection) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Collection);
        }
        if (hasDataModel) {
          size += pb::CodedOutputStream.ComputeEnumSize(3, (int) DataModel);
        }
        if (hasCriteria) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, Criteria);
        }
        if (hasLimit) {
          size += pb::CodedOutputStream.ComputeMessageSize(5, Limit);
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          size += pb::CodedOutputStream.ComputeMessageSize(6, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PrepareDelete ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PrepareDelete ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PrepareDelete ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PrepareDelete ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PrepareDelete ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PrepareDelete ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PrepareDelete ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PrepareDelete ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PrepareDelete ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PrepareDelete ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PrepareDelete MakeReadOnly() {
      order_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PrepareDelete prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<PrepareDelete, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PrepareDelete cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PrepareDelete result;
      
      private PrepareDelete PrepareBuilder() {
        if (resultIsReadOnly) {
          PrepareDelete original = result;
          result = new PrepareDelete();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PrepareDelete MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.PrepareDelete.Descriptor; }
      }
      
      public override PrepareDelete DefaultInstanceForType {
        get { return global::Mysqlx.Crud.PrepareDelete.DefaultInstance; }
      }
      
      public override PrepareDelete BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PrepareDelete) {
          return MergeFrom((PrepareDelete) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PrepareDelete other) {
        if (other == global::Mysqlx.Crud.PrepareDelete.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStmtId) {
          StmtId = other.StmtId;
        }
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        if (other.HasCriteria) {
          MergeCriteria(other.Criteria);
        }
        if (other.HasLimit) {
          MergeLimit(other.Limit);
        }
        if (other.order_.Count != 0) {
          result.order_.Add(other.order_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_prepareDeleteFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _prepareDeleteFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStmtId = input.ReadUInt32(ref result.stmtId_);
              break;
            }
            case 18: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
            case 34: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasCriteria) {
                subBuilder.MergeFrom(Criteria);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Criteria = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              global::Mysqlx.Crud.Limit.Builder subBuilder = global::Mysqlx.Crud.Limit.CreateBuilder();
              if (result.hasLimit) {
                subBuilder.MergeFrom(Limit);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Limit = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              input.ReadMessageArray(tag, field_name, result.order_, global::Mysqlx.Crud.Order.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStmtId {
        get { return result.hasStmtId; }
      }
      public uint StmtId {
        get { return result.StmtId; }
        set { SetStmtId(value); }
      }
      public Builder SetStmtId(uint value) {
        PrepareBuilder();
        result.hasStmtId = true;
        result.stmtId_ = value;
        return this;
      }
      public Builder ClearStmtId() {
        PrepareBuilder();
        result.hasStmtId = false;
        result.stmtId_ = 0;
        return this;
      }
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
      
      public bool HasCriteria {
       get { return result.hasCriteria; }
      }
      public global::Mysqlx.Expr.Expr Criteria {
        get { return result.Criteria; }
        set { SetCriteria(value); }
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = value;
        return this;
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCriteria &&
            result.criteria_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.criteria_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.criteria_).MergeFrom(value).BuildPartial();
        } else {
          result.criteria_ = value;
        }
        result.hasCriteria = true;
        return this;
      }
      public Builder ClearCriteria() {
        PrepareBuilder();
        result.hasCriteria = false;
        result.criteria_ = null;
        return this;
      }
      
      public bool HasLimit {
       get { return result.hasLimit; }
      }
      public global::Mysqlx.Crud.Limit Limit {
        get { return result.Limit; }
        set { SetLimit(value); }
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = value;
        return this;
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLimit &&
            result.limit_ != global::Mysqlx.Crud.Limit.DefaultInstance) {
            result.limit_ = global::Mysqlx.Crud.Limit.CreateBuilder(result.limit_).MergeFrom(value).BuildPartial();
        } else {
          result.limit_ = value;
        }
        result.hasLimit = true;
        return this;
      }
      public Builder ClearLimit() {
        PrepareBuilder();
        result.hasLimit = false;
        result.limit_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Order> OrderList {
        get { return PrepareBuilder().order_; }
      }
      public int OrderCount {
        get { return result.OrderCount; }
      }
      public global::Mysqlx.Crud.Order GetOrder(int index) {
        return result.GetOrder(index);
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_[index] = value;
        return this;
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_.Add(value);
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeOrder(scg::IEnumerable<global::Mysqlx.Crud.Order> values) {
        PrepareBuilder();
        result.order_.Add(values);
        return this;
      }
      public Builder ClearOrder() {
        PrepareBuilder();
        result.order_.Clear();
        return this;
      }
    }
    static PrepareDelete() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Find : pb::GeneratedMessage<Find, Find.Builder> {
    private Find() { }
    private static readonly Find defaultInstance = new Find().MakeReadOnly();
    private static readonly string[] _findFieldNames = new string[] { "collection", "criteria", "data_model", "limit", "order", "projection" };
    private static readonly uint[] _findFieldTags = new uint[] { 18, 42, 24, 50, 58, 34 };
    public static Find DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Find DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Find ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Find__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Find, Find.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Find__FieldAccessorTable; }
    }
    
    public const int CollectionFieldNumber = 2;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 3;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public const int ProjectionFieldNumber = 4;
    private pbc::PopsicleList<global::Mysqlx.Crud.Column> projection_ = new pbc::PopsicleList<global::Mysqlx.Crud.Column>();
    public scg::IList<global::Mysqlx.Crud.Column> ProjectionList {
      get { return projection_; }
    }
    public int ProjectionCount {
      get { return projection_.Count; }
    }
    public global::Mysqlx.Crud.Column GetProjection(int index) {
      return projection_[index];
    }
    
    public const int CriteriaFieldNumber = 5;
    private bool hasCriteria;
    private global::Mysqlx.Expr.Expr criteria_;
    public bool HasCriteria {
      get { return hasCriteria; }
    }
    public global::Mysqlx.Expr.Expr Criteria {
      get { return criteria_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public const int LimitFieldNumber = 6;
    private bool hasLimit;
    private global::Mysqlx.Crud.Limit limit_;
    public bool HasLimit {
      get { return hasLimit; }
    }
    public global::Mysqlx.Crud.Limit Limit {
      get { return limit_ ?? global::Mysqlx.Crud.Limit.DefaultInstance; }
    }
    
    public const int OrderFieldNumber = 7;
    private pbc::PopsicleList<global::Mysqlx.Crud.Order> order_ = new pbc::PopsicleList<global::Mysqlx.Crud.Order>();
    public scg::IList<global::Mysqlx.Crud.Order> OrderList {
      get { return order_; }
    }
    public int OrderCount {
      get { return order_.Count; }
    }
    public global::Mysqlx.Crud.Order GetOrder(int index) {
      return order_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        foreach (global::Mysqlx.Crud.Column element in ProjectionList) {
          if (!element.IsInitialized) return false;
        }
        if (HasCriteria) {
          if (!Criteria.IsInitialized) return false;
        }
        if (HasLimit) {
          if (!Limit.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _findFieldNames;
      if (hasCollection) {
        output.WriteMessage(2, field_names[0], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(3, field_names[2], (int) DataModel, DataModel);
      }
      if (projection_.Count > 0) {
        output.WriteMessageArray(4, field_names[5], projection_);
      }
      if (hasCriteria) {
        output.WriteMessage(5, field_names[1], Criteria);
      }
      if (hasLimit) {
        output.WriteMessage(6, field_names[3], Limit);
      }
      if (order_.Count > 0) {
        output.WriteMessageArray(7, field_names[4], order_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCollection) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Collection);
        }
        if (hasDataModel) {
          size += pb::CodedOutputStream.ComputeEnumSize(3, (int) DataModel);
        }
        foreach (global::Mysqlx.Crud.Column element in ProjectionList) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, element);
        }
        if (hasCriteria) {
          size += pb::CodedOutputStream.ComputeMessageSize(5, Criteria);
        }
        if (hasLimit) {
          size += pb::CodedOutputStream.ComputeMessageSize(6, Limit);
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          size += pb::CodedOutputStream.ComputeMessageSize(7, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Find ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Find ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Find ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Find ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Find ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Find ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Find ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Find ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Find ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Find ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Find MakeReadOnly() {
      projection_.MakeReadOnly();
      order_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Find prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Find, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Find cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Find result;
      
      private Find PrepareBuilder() {
        if (resultIsReadOnly) {
          Find original = result;
          result = new Find();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Find MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Find.Descriptor; }
      }
      
      public override Find DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Find.DefaultInstance; }
      }
      
      public override Find BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Find) {
          return MergeFrom((Find) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Find other) {
        if (other == global::Mysqlx.Crud.Find.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        if (other.projection_.Count != 0) {
          result.projection_.Add(other.projection_);
        }
        if (other.HasCriteria) {
          MergeCriteria(other.Criteria);
        }
        if (other.HasLimit) {
          MergeLimit(other.Limit);
        }
        if (other.order_.Count != 0) {
          result.order_.Add(other.order_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_findFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _findFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 18: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
            case 34: {
              input.ReadMessageArray(tag, field_name, result.projection_, global::Mysqlx.Crud.Column.DefaultInstance, extensionRegistry);
              break;
            }
            case 42: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasCriteria) {
                subBuilder.MergeFrom(Criteria);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Criteria = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              global::Mysqlx.Crud.Limit.Builder subBuilder = global::Mysqlx.Crud.Limit.CreateBuilder();
              if (result.hasLimit) {
                subBuilder.MergeFrom(Limit);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Limit = subBuilder.BuildPartial();
              break;
            }
            case 58: {
              input.ReadMessageArray(tag, field_name, result.order_, global::Mysqlx.Crud.Order.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Column> ProjectionList {
        get { return PrepareBuilder().projection_; }
      }
      public int ProjectionCount {
        get { return result.ProjectionCount; }
      }
      public global::Mysqlx.Crud.Column GetProjection(int index) {
        return result.GetProjection(index);
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Column value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_[index] = value;
        return this;
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Column.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Column value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_.Add(value);
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Column.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeProjection(scg::IEnumerable<global::Mysqlx.Crud.Column> values) {
        PrepareBuilder();
        result.projection_.Add(values);
        return this;
      }
      public Builder ClearProjection() {
        PrepareBuilder();
        result.projection_.Clear();
        return this;
      }
      
      public bool HasCriteria {
       get { return result.hasCriteria; }
      }
      public global::Mysqlx.Expr.Expr Criteria {
        get { return result.Criteria; }
        set { SetCriteria(value); }
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = value;
        return this;
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCriteria &&
            result.criteria_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.criteria_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.criteria_).MergeFrom(value).BuildPartial();
        } else {
          result.criteria_ = value;
        }
        result.hasCriteria = true;
        return this;
      }
      public Builder ClearCriteria() {
        PrepareBuilder();
        result.hasCriteria = false;
        result.criteria_ = null;
        return this;
      }
      
      public bool HasLimit {
       get { return result.hasLimit; }
      }
      public global::Mysqlx.Crud.Limit Limit {
        get { return result.Limit; }
        set { SetLimit(value); }
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = value;
        return this;
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLimit &&
            result.limit_ != global::Mysqlx.Crud.Limit.DefaultInstance) {
            result.limit_ = global::Mysqlx.Crud.Limit.CreateBuilder(result.limit_).MergeFrom(value).BuildPartial();
        } else {
          result.limit_ = value;
        }
        result.hasLimit = true;
        return this;
      }
      public Builder ClearLimit() {
        PrepareBuilder();
        result.hasLimit = false;
        result.limit_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Order> OrderList {
        get { return PrepareBuilder().order_; }
      }
      public int OrderCount {
        get { return result.OrderCount; }
      }
      public global::Mysqlx.Crud.Order GetOrder(int index) {
        return result.GetOrder(index);
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_[index] = value;
        return this;
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_.Add(value);
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeOrder(scg::IEnumerable<global::Mysqlx.Crud.Order> values) {
        PrepareBuilder();
        result.order_.Add(values);
        return this;
      }
      public Builder ClearOrder() {
        PrepareBuilder();
        result.order_.Clear();
        return this;
      }
    }
    static Find() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Insert : pb::GeneratedMessage<Insert, Insert.Builder> {
    private Insert() { }
    private static readonly Insert defaultInstance = new Insert().MakeReadOnly();
    private static readonly string[] _insertFieldNames = new string[] { "collection", "data_model", "projection", "row" };
    private static readonly uint[] _insertFieldTags = new uint[] { 10, 16, 26, 34 };
    public static Insert DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Insert DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Insert ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Insert__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Insert, Insert.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Insert__FieldAccessorTable; }
    }
    
    public const int CollectionFieldNumber = 1;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 2;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public const int ProjectionFieldNumber = 3;
    private pbc::PopsicleList<global::Mysqlx.Crud.Column> projection_ = new pbc::PopsicleList<global::Mysqlx.Crud.Column>();
    public scg::IList<global::Mysqlx.Crud.Column> ProjectionList {
      get { return projection_; }
    }
    public int ProjectionCount {
      get { return projection_.Count; }
    }
    public global::Mysqlx.Crud.Column GetProjection(int index) {
      return projection_[index];
    }
    
    public const int RowFieldNumber = 4;
    private pbc::PopsicleList<global::Mysqlx.Sql.Row> row_ = new pbc::PopsicleList<global::Mysqlx.Sql.Row>();
    public scg::IList<global::Mysqlx.Sql.Row> RowList {
      get { return row_; }
    }
    public int RowCount {
      get { return row_.Count; }
    }
    public global::Mysqlx.Sql.Row GetRow(int index) {
      return row_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        foreach (global::Mysqlx.Crud.Column element in ProjectionList) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Sql.Row element in RowList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _insertFieldNames;
      if (hasCollection) {
        output.WriteMessage(1, field_names[0], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(2, field_names[1], (int) DataModel, DataModel);
      }
      if (projection_.Count > 0) {
        output.WriteMessageArray(3, field_names[2], projection_);
      }
      if (row_.Count > 0) {
        output.WriteMessageArray(4, field_names[3], row_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCollection) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Collection);
        }
        if (hasDataModel) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) DataModel);
        }
        foreach (global::Mysqlx.Crud.Column element in ProjectionList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        foreach (global::Mysqlx.Sql.Row element in RowList) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Insert ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Insert ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Insert ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Insert ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Insert ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Insert ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Insert ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Insert ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Insert ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Insert ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Insert MakeReadOnly() {
      projection_.MakeReadOnly();
      row_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Insert prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Insert, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Insert cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Insert result;
      
      private Insert PrepareBuilder() {
        if (resultIsReadOnly) {
          Insert original = result;
          result = new Insert();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Insert MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Insert.Descriptor; }
      }
      
      public override Insert DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Insert.DefaultInstance; }
      }
      
      public override Insert BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Insert) {
          return MergeFrom((Insert) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Insert other) {
        if (other == global::Mysqlx.Crud.Insert.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        if (other.projection_.Count != 0) {
          result.projection_.Add(other.projection_);
        }
        if (other.row_.Count != 0) {
          result.row_.Add(other.row_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_insertFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _insertFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.projection_, global::Mysqlx.Crud.Column.DefaultInstance, extensionRegistry);
              break;
            }
            case 34: {
              input.ReadMessageArray(tag, field_name, result.row_, global::Mysqlx.Sql.Row.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Column> ProjectionList {
        get { return PrepareBuilder().projection_; }
      }
      public int ProjectionCount {
        get { return result.ProjectionCount; }
      }
      public global::Mysqlx.Crud.Column GetProjection(int index) {
        return result.GetProjection(index);
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Column value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_[index] = value;
        return this;
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Column.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Column value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_.Add(value);
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Column.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeProjection(scg::IEnumerable<global::Mysqlx.Crud.Column> values) {
        PrepareBuilder();
        result.projection_.Add(values);
        return this;
      }
      public Builder ClearProjection() {
        PrepareBuilder();
        result.projection_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Sql.Row> RowList {
        get { return PrepareBuilder().row_; }
      }
      public int RowCount {
        get { return result.RowCount; }
      }
      public global::Mysqlx.Sql.Row GetRow(int index) {
        return result.GetRow(index);
      }
      public Builder SetRow(int index, global::Mysqlx.Sql.Row value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.row_[index] = value;
        return this;
      }
      public Builder SetRow(int index, global::Mysqlx.Sql.Row.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.row_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddRow(global::Mysqlx.Sql.Row value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.row_.Add(value);
        return this;
      }
      public Builder AddRow(global::Mysqlx.Sql.Row.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.row_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeRow(scg::IEnumerable<global::Mysqlx.Sql.Row> values) {
        PrepareBuilder();
        result.row_.Add(values);
        return this;
      }
      public Builder ClearRow() {
        PrepareBuilder();
        result.row_.Clear();
        return this;
      }
    }
    static Insert() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Update : pb::GeneratedMessage<Update, Update.Builder> {
    private Update() { }
    private static readonly Update defaultInstance = new Update().MakeReadOnly();
    private static readonly string[] _updateFieldNames = new string[] { "collection", "data_model" };
    private static readonly uint[] _updateFieldTags = new uint[] { 18, 24 };
    public static Update DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Update DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Update ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Update__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Update, Update.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Update__FieldAccessorTable; }
    }
    
    public const int CollectionFieldNumber = 2;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 3;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _updateFieldNames;
      if (hasCollection) {
        output.WriteMessage(2, field_names[0], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(3, field_names[1], (int) DataModel, DataModel);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCollection) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Collection);
        }
        if (hasDataModel) {
          size += pb::CodedOutputStream.ComputeEnumSize(3, (int) DataModel);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Update ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Update ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Update ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Update ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Update ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Update ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Update ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Update ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Update ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Update ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Update MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Update prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Update, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Update cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Update result;
      
      private Update PrepareBuilder() {
        if (resultIsReadOnly) {
          Update original = result;
          result = new Update();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Update MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Update.Descriptor; }
      }
      
      public override Update DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Update.DefaultInstance; }
      }
      
      public override Update BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Update) {
          return MergeFrom((Update) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Update other) {
        if (other == global::Mysqlx.Crud.Update.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_updateFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _updateFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 18: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
    }
    static Update() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Delete : pb::GeneratedMessage<Delete, Delete.Builder> {
    private Delete() { }
    private static readonly Delete defaultInstance = new Delete().MakeReadOnly();
    private static readonly string[] _deleteFieldNames = new string[] { "collection", "criteria", "data_model", "limit", "order" };
    private static readonly uint[] _deleteFieldTags = new uint[] { 10, 26, 16, 34, 42 };
    public static Delete DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Delete DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Delete ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Delete__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Delete, Delete.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Delete__FieldAccessorTable; }
    }
    
    public const int CollectionFieldNumber = 1;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 2;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public const int CriteriaFieldNumber = 3;
    private bool hasCriteria;
    private global::Mysqlx.Expr.Expr criteria_;
    public bool HasCriteria {
      get { return hasCriteria; }
    }
    public global::Mysqlx.Expr.Expr Criteria {
      get { return criteria_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public const int LimitFieldNumber = 4;
    private bool hasLimit;
    private global::Mysqlx.Crud.Limit limit_;
    public bool HasLimit {
      get { return hasLimit; }
    }
    public global::Mysqlx.Crud.Limit Limit {
      get { return limit_ ?? global::Mysqlx.Crud.Limit.DefaultInstance; }
    }
    
    public const int OrderFieldNumber = 5;
    private pbc::PopsicleList<global::Mysqlx.Crud.Order> order_ = new pbc::PopsicleList<global::Mysqlx.Crud.Order>();
    public scg::IList<global::Mysqlx.Crud.Order> OrderList {
      get { return order_; }
    }
    public int OrderCount {
      get { return order_.Count; }
    }
    public global::Mysqlx.Crud.Order GetOrder(int index) {
      return order_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        if (HasCriteria) {
          if (!Criteria.IsInitialized) return false;
        }
        if (HasLimit) {
          if (!Limit.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _deleteFieldNames;
      if (hasCollection) {
        output.WriteMessage(1, field_names[0], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(2, field_names[2], (int) DataModel, DataModel);
      }
      if (hasCriteria) {
        output.WriteMessage(3, field_names[1], Criteria);
      }
      if (hasLimit) {
        output.WriteMessage(4, field_names[3], Limit);
      }
      if (order_.Count > 0) {
        output.WriteMessageArray(5, field_names[4], order_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCollection) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Collection);
        }
        if (hasDataModel) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) DataModel);
        }
        if (hasCriteria) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Criteria);
        }
        if (hasLimit) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, Limit);
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          size += pb::CodedOutputStream.ComputeMessageSize(5, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Delete ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Delete ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Delete ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Delete ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Delete ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Delete ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Delete ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Delete ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Delete ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Delete ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Delete MakeReadOnly() {
      order_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Delete prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal sealed partial class Builder : pb::GeneratedBuilder<Delete, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Delete cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Delete result;
      
      private Delete PrepareBuilder() {
        if (resultIsReadOnly) {
          Delete original = result;
          result = new Delete();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Delete MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Delete.Descriptor; }
      }
      
      public override Delete DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Delete.DefaultInstance; }
      }
      
      public override Delete BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Delete) {
          return MergeFrom((Delete) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Delete other) {
        if (other == global::Mysqlx.Crud.Delete.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        if (other.HasCriteria) {
          MergeCriteria(other.Criteria);
        }
        if (other.HasLimit) {
          MergeLimit(other.Limit);
        }
        if (other.order_.Count != 0) {
          result.order_.Add(other.order_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_deleteFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _deleteFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 26: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasCriteria) {
                subBuilder.MergeFrom(Criteria);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Criteria = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::Mysqlx.Crud.Limit.Builder subBuilder = global::Mysqlx.Crud.Limit.CreateBuilder();
              if (result.hasLimit) {
                subBuilder.MergeFrom(Limit);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Limit = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              input.ReadMessageArray(tag, field_name, result.order_, global::Mysqlx.Crud.Order.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
      
      public bool HasCriteria {
       get { return result.hasCriteria; }
      }
      public global::Mysqlx.Expr.Expr Criteria {
        get { return result.Criteria; }
        set { SetCriteria(value); }
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = value;
        return this;
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCriteria &&
            result.criteria_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.criteria_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.criteria_).MergeFrom(value).BuildPartial();
        } else {
          result.criteria_ = value;
        }
        result.hasCriteria = true;
        return this;
      }
      public Builder ClearCriteria() {
        PrepareBuilder();
        result.hasCriteria = false;
        result.criteria_ = null;
        return this;
      }
      
      public bool HasLimit {
       get { return result.hasLimit; }
      }
      public global::Mysqlx.Crud.Limit Limit {
        get { return result.Limit; }
        set { SetLimit(value); }
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = value;
        return this;
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLimit &&
            result.limit_ != global::Mysqlx.Crud.Limit.DefaultInstance) {
            result.limit_ = global::Mysqlx.Crud.Limit.CreateBuilder(result.limit_).MergeFrom(value).BuildPartial();
        } else {
          result.limit_ = value;
        }
        result.hasLimit = true;
        return this;
      }
      public Builder ClearLimit() {
        PrepareBuilder();
        result.hasLimit = false;
        result.limit_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Order> OrderList {
        get { return PrepareBuilder().order_; }
      }
      public int OrderCount {
        get { return result.OrderCount; }
      }
      public global::Mysqlx.Crud.Order GetOrder(int index) {
        return result.GetOrder(index);
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_[index] = value;
        return this;
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_.Add(value);
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeOrder(scg::IEnumerable<global::Mysqlx.Crud.Order> values) {
        PrepareBuilder();
        result.order_.Add(values);
        return this;
      }
      public Builder ClearOrder() {
        PrepareBuilder();
        result.order_.Clear();
        return this;
      }
    }
    static Delete() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
